/*! For license information please see build.js.LICENSE.txt */
!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["react","react-dom"],n):"object"==typeof exports?exports["react-super-simple-scroller"]=n(require("react"),require("react-dom")):e["react-super-simple-scroller"]=n(e.react,e["react-dom"])}(self,(__WEBPACK_EXTERNAL_MODULE_react__,__WEBPACK_EXTERNAL_MODULE_react_dom__)=>(()=>{"use strict";var __webpack_modules__={"./src/Queue.tsx":(__unused_webpack_module,exports)=>{eval('\n\n// queueClass.tsx\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n// h/t https://medium.com/@karenmarkosyan/how-to-manage-promises-into-dynamic-queue-with-vanilla-javascript-9d0d1f8d4df5\nclass Queue {\n  constructor() {\n    this.queue = [];\n    this.pendingPromise = false;\n  }\n  enqueue(promise) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        promise,\n        resolve,\n        reject\n      });\n      this.dequeue();\n    });\n  }\n  dequeue() {\n    if (this.pendingPromise) {\n      return false;\n    }\n    const item = this.queue.shift();\n    if (!item) {\n      return false;\n    }\n    try {\n      this.pendingPromise = true;\n      item.promise().then(value => {\n        this.pendingPromise = false;\n        item.resolve(value);\n        this.dequeue();\n      }).catch(err => {\n        this.pendingPromise = false;\n        item.reject(err);\n        this.dequeue();\n      });\n    } catch (err) {\n      this.pendingPromise = false;\n      item.reject(err);\n      this.dequeue();\n    }\n    return true;\n  }\n}\nexports["default"] = Queue;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/Queue.tsx?')},"./src/ReactSuperSimpleScroller.tsx":function(__unused_webpack_module,exports,__webpack_require__){eval("\n\n// ReactSuperSimpleScroller.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var ownKeys = function (o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n// ===============================[ resources ]========================\nconst react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\n// import { createPortal } from 'react-dom'\nconst Queue_1 = __importDefault(__webpack_require__(/*! ./Queue */ \"./src/Queue.tsx\"));\nconst orientationStyles_1 = __webpack_require__(/*! ./orientationStyles */ \"./src/orientationStyles.tsx\");\n// sub-modules\nconst utilities_1 = __webpack_require__(/*! ./utilities */ \"./src/utilities.tsx\");\nconst useCells_1 = __importDefault(__webpack_require__(/*! ./useCells */ \"./src/useCells.tsx\"));\nconst useNewCradlePotential_1 = __importDefault(__webpack_require__(/*! ./useNewCradlePotential */ \"./src/useNewCradlePotential.tsx\"));\nconst useRemoveCells_1 = __importDefault(__webpack_require__(/*! ./useRemoveCells */ \"./src/useRemoveCells.tsx\"));\nconst useIntersections_1 = __importDefault(__webpack_require__(/*! ./useIntersections */ \"./src/useIntersections.tsx\"));\nconst useReset_1 = __importDefault(__webpack_require__(/*! ./useReset */ \"./src/useReset.tsx\"));\nconst useCalls_1 = __importDefault(__webpack_require__(/*! ./useCalls */ \"./src/useCalls.tsx\"));\nconst orientationStyles_2 = __webpack_require__(/*! ./orientationStyles */ \"./src/orientationStyles.tsx\");\nconst utilities_2 = __webpack_require__(/*! ./utilities */ \"./src/utilities.tsx\");\nconst AXIS_START_POSITION = orientationStyles_1.SCROLLBLOCK_SPAN / 2,\n  // defaults for below\n  DEFAULT_STANDARD_SCROLL_MOMENTUM_FADE = 700,\n  DEFAULT_SHORT_MOMENTUM_FADE = 200,\n  DEFAULT_RUNWAY_BANDS = 4;\nlet\n  // can be set by parameter\n  STANDARD_SCROLL_MOMENTUM_FADE = DEFAULT_STANDARD_SCROLL_MOMENTUM_FADE,\n  SHORT_MOMENTUM_FADE = DEFAULT_SHORT_MOMENTUM_FADE,\n  // only first time for resize callback\n  RUNWAY_BANDS = DEFAULT_RUNWAY_BANDS;\n// ===============================[ styles ]==========================\n// common styles\nconst viewportStyles = {\n  position: 'absolute',\n  inset: 0,\n  // backgroundColor:'cyan',\n  overflow: 'auto',\n  scrollbarWidth: 'none',\n  overscrollBehavior: 'none',\n  overflowAnchor: 'none'\n};\nconst virtualCradleStyles = {\n  display: 'none'\n};\n// note: remaining styles are in orientationStyles.tsx\n// ==========================[ component ]============================\nconst Viewport = props => {\n  // ===============================[ data ]==========================\n  const\n    // host data\n    {\n      orientation,\n      layout,\n      cellDimensions,\n      seedReferenceID,\n      fetchCells,\n      callbacks,\n      calls,\n      spacing,\n      operations = {},\n      scrollerName = 'not named'\n    } = props,\n    scrollerQueueRef = (0, react_1.useRef)(new Queue_1.default()),\n    // comparisons with the following lead to reset\n    previousOrientationRef = (0, react_1.useRef)(orientation),\n    previousLayoutRef = (0, react_1.useRef)(layout),\n    previousCellDimensionsRef = (0, react_1.useRef)(cellDimensions),\n    previousSpacingRef = (0, react_1.useRef)(spacing),\n    previousSeedReferenceIDRef = (0, react_1.useRef)(seedReferenceID),\n    previousFetchCellsRef = (0, react_1.useRef)(fetchCells),\n    fetchCellsRef = (0, react_1.useRef)(fetchCells),\n    orientationRef = (0, react_1.useRef)(null),\n    layoutRef = (0, react_1.useRef)(null),\n    cellDimensionsRef = (0, react_1.useRef)(null),\n    seedReferenceIDRef = (0, react_1.useRef)(null),\n    callbacksRef = (0, react_1.useRef)(null),\n    callsRef = (0, react_1.useRef)(null),\n    spacingRef = (0, react_1.useRef)(null),\n    operationsRef = (0, react_1.useRef)(null),\n    // base states\n    [scrollerState, setScrollerState] = (0, react_1.useState)('setup'),\n    scrollerStateRef = (0, react_1.useRef)(null),\n    [viewportDimensions, setViewportDimensions] = (0, react_1.useState)(null),\n    [styles, setStyles] = (0, react_1.useState)((0, orientationStyles_2.selectStyles)(orientation)),\n    // scroller structure\n    viewportRef = (0, react_1.useRef)(null),\n    scrollblockRef = (0, react_1.useRef)(null),\n    axisRef = (0, react_1.useRef)(null),\n    // ...headblock\n    headblockRef = (0, react_1.useRef)(null),\n    leadHeadblockBandRef = (0, react_1.useRef)(null),\n    leadHeadblockBandBackwardTriggerRef = (0, react_1.useRef)(null),\n    headblockOverflowTriggerRef = (0, react_1.useRef)(null),\n    // ...tailblock\n    tailblockRef = (0, react_1.useRef)(null),\n    leadTailblockBandRef = (0, react_1.useRef)(null),\n    leadTailblockBandStartTriggerRef = (0, react_1.useRef)(null),\n    leadTailblockBandEndTriggerRef = (0, react_1.useRef)(null),\n    tailblockOverflowTriggerRef = (0, react_1.useRef)(null),\n    // scroller configuration\n    [cradlePotential, setCradlePotential] = (0, react_1.useState)(null),\n    // maximal configuration\n    cradlePotentialRef = (0, react_1.useRef)(null),\n    // immediate access\n    cradleActualRef = (0, react_1.useRef)(Object.assign({\n      orientation,\n      layout\n    }, utilities_2.baseCradleActual)),\n    // actual configuration\n    axisPositionRef = (0, react_1.useRef)({\n      x: 0,\n      y: AXIS_START_POSITION\n    }),\n    cradleMarginsRef = (0, react_1.useRef)(null),\n    bandPaddingRef = (0, react_1.useRef)(null),\n    cellGapRef = (0, react_1.useRef)(null),\n    // cell tracking -- cells are listed in presentation order\n    currentAxisReferenceIDRef = (0, react_1.useRef)(seedReferenceID),\n    cellDataListRef = (0, react_1.useRef)([]),\n    // host cell data\n    portalIDListRef = (0, react_1.useRef)([]),\n    // sync with cellPortalListRef, to find portal position\n    cellPortalListRef = (0, react_1.useRef)([]),\n    // immediate access\n    portalContainerMapRef = (0, react_1.useRef)(new Map()),\n    // id -> containerElement\n    [portalRenderList, setPortalRenderList] = (0, react_1.useState)([]),\n    // portal render\n    // band tracking -- bands are listed in presentaton order\n    headBandListRef = (0, react_1.useRef)([]),\n    tailBandListRef = (0, react_1.useRef)([]),\n    // scroll data\n    scrollTopRef = (0, react_1.useRef)(0),\n    scrollLeftRef = (0, react_1.useRef)(0),\n    // scrollDirectionVerticalRef = useRef(0),\n    // scrollDirectionHorizontalRef = useRef(0),\n    [isScrollingMode, setIsScrollingMode] = (0, react_1.useState)(false),\n    immediateIsScrollingRef = (0, react_1.useRef)(false),\n    immediateStopScrollingRef = (0, react_1.useRef)(false),\n    // observers\n    intersectionObserverRef = (0, react_1.useRef)(null),\n    intersectionsMapRef = (0, react_1.useRef)(new Map()),\n    // combined state, for intersections evaluation\n    resizeObserverRef = (0, react_1.useRef)(null),\n    cradleMutationObserverRef = (0, react_1.useRef)(null),\n    bandMutationObserverRef = (0, react_1.useRef)(null),\n    // timeout id's\n    scrollMomentumTimeoutIDRef = (0, react_1.useRef)(null),\n    restoreScrollingTimeoutIDRef = (0, react_1.useRef)(null),\n    resizeTimeoutIDRef = (0, react_1.useRef)(null);\n  // persistent, modifiable access\n  orientationRef.current = orientation;\n  layoutRef.current = layout;\n  cellDimensionsRef.current = cellDimensions;\n  seedReferenceIDRef.current = seedReferenceID;\n  // fetchCellsRef.current = fetchCells\n  // spacingRef.current = spacing\n  callbacksRef.current = callbacks;\n  callsRef.current = calls;\n  operationsRef.current = operations;\n  cradlePotentialRef.current = cradlePotential;\n  scrollerStateRef.current = scrollerState;\n  // --- component utility functions\n  const intersectionsDisconnect = () => {\n    intersectionObserverRef.current.disconnect();\n  };\n  const intersectionsConnect = () => {\n    intersectionsMapRef.current.clear();\n    headblockOverflowTriggerRef.current && intersectionObserverRef.current.observe(headblockOverflowTriggerRef.current);\n    leadHeadblockBandRef.current && intersectionObserverRef.current.observe(leadHeadblockBandRef.current);\n    leadHeadblockBandBackwardTriggerRef.current && intersectionObserverRef.current.observe(leadHeadblockBandBackwardTriggerRef.current);\n    leadTailblockBandRef.current && intersectionObserverRef.current.observe(leadTailblockBandRef.current);\n    leadTailblockBandStartTriggerRef.current && intersectionObserverRef.current.observe(leadTailblockBandStartTriggerRef.current);\n    leadTailblockBandEndTriggerRef.current && intersectionObserverRef.current.observe(leadTailblockBandEndTriggerRef.current);\n    tailblockOverflowTriggerRef.current && intersectionObserverRef.current.observe(tailblockOverflowTriggerRef.current);\n  };\n  // setAxisPosition has to be defined ahead of useIntersections paramater\n  const setAxisPosition = (0, react_1.useCallback)((x, y, source = 'general') => {\n    const xpx = x + 'px',\n      ypx = y + 'px',\n      translate = `translate(${xpx},${ypx})`;\n    axisPositionRef.current = {\n      x,\n      y\n    };\n    axisRef.current.style.transform = translate;\n  }, []);\n  const updateCurrentAxisReferenceID = () => {\n    var _a;\n    const currentAxisReferenceID = portalIDListRef.current.at(-cradleActualRef.current.forwardCells);\n    if (currentAxisReferenceID !== currentAxisReferenceIDRef.current) {\n      currentAxisReferenceIDRef.current = currentAxisReferenceID;\n      ((_a = callbacksRef.current) === null || _a === void 0 ? void 0 : _a.axisReferenceID) && callbacksRef.current.axisReferenceID(currentAxisReferenceID);\n    }\n  };\n  const trimCradle = () => {\n    const cradleActual = cradleActualRef.current,\n      cradlePotential = cradlePotentialRef.current,\n      tailBandList = tailBandListRef.current;\n    let tailCellOffset = 0;\n    if (tailBandList.length > 1) {\n      tailCellOffset = cradleActual.cellsPerBand - tailBandList[0].childElementCount;\n    }\n    const forwardBandsToRemoveCount = Math.max(cradleActual.forwardBands - cradlePotential.forwardBands, 0),\n      backwardBandsToRemoveCount = Math.max(cradleActual.backwardBands - cradlePotential.backwardBands, 0),\n      forwardCellsToRemoveCount = Math.max(cradleActual.forwardCells - (cradlePotential.forwardCells - tailCellOffset), 0),\n      backwardCellsToRemoveCount = Math.max(cradleActual.backwardCells - cradlePotential.backwardCells, 0);\n    removeCells({\n      forwardCellsToRemoveCount,\n      forwardBandsToRemoveCount,\n      backwardCellsToRemoveCount,\n      backwardBandsToRemoveCount\n    });\n  };\n  const fillCradle = () => __awaiter(void 0, void 0, void 0, function* () {\n    yield getCells('forward'); // returns promise\n  });\n  const getSeed = referenceID => __awaiter(void 0, void 0, void 0, function* () {\n    if (!(0, utilities_1.isValidID)(referenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'getSeed',\n          message: 'must be a valid referenceID',\n          arguments: [referenceID],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    yield getCells('seed', referenceID);\n  });\n  const resetAxisPosition = () => {\n    if (orientationRef.current == 'vertical') {\n      const axisOffset = axisPositionRef.current.y - viewportRef.current.scrollTop;\n      scrollTopRef.current = AXIS_START_POSITION;\n      viewportRef.current.scrollTo(scrollLeftRef.current, AXIS_START_POSITION);\n      setAxisPosition(0, AXIS_START_POSITION + axisOffset, 'stop scrolling');\n    } else {\n      // 'horizontal'\n      const axisOffset = axisPositionRef.current.x - viewportRef.current.scrollLeft;\n      scrollLeftRef.current = AXIS_START_POSITION;\n      viewportRef.current.scrollTo(AXIS_START_POSITION, scrollTopRef.current);\n      setAxisPosition(AXIS_START_POSITION + axisOffset, 0);\n    }\n  };\n  // ===================[ breakout code to use* modules ]======================\n  const getCells = (0, useCells_1.default)({\n      scrollerName,\n      orientationRef,\n      layoutRef,\n      spacingRef,\n      cradlePotentialRef,\n      cradleActualRef,\n      cellPortalListRef,\n      portalIDListRef,\n      cellDataListRef,\n      portalContainerMapRef,\n      cellDimensionsRef,\n      tailblockRef,\n      tailBandListRef,\n      leadTailblockBandRef,\n      headblockRef,\n      headBandListRef,\n      leadHeadblockBandRef,\n      // callbacksRef,\n      setPortalRenderList,\n      fetchCellsRef,\n      updateCurrentAxisReferenceID,\n      callbacksRef,\n      bandMutationObserverRef\n    }),\n    removeCells = (0, useRemoveCells_1.default)({\n      portalIDListRef,\n      cellPortalListRef,\n      cellDataListRef,\n      portalContainerMapRef,\n      headBandListRef,\n      tailBandListRef,\n      cradleActualRef,\n      callbacksRef\n    }),\n    evaluateIntersections = (0, useIntersections_1.default)({\n      orientationRef,\n      intersectionsMapRef,\n      immediateIsScrollingRef,\n      viewportRef,\n      immediateStopScrollingRef,\n      scrollTopRef,\n      scrollLeftRef,\n      restoreScrollingTimeoutIDRef,\n      STANDARD_SCROLL_MOMENTUM_FADE,\n      AXIS_START_POSITION,\n      axisPositionRef,\n      cradleActualRef,\n      tailblockOverflowTriggerRef,\n      cradlePotentialRef,\n      headblockRef,\n      headBandListRef,\n      tailblockRef,\n      tailBandListRef,\n      leadHeadblockBandRef,\n      headblockOverflowTriggerRef,\n      leadTailblockBandRef,\n      portalIDListRef,\n      // callbacksRef,\n      setAxisPosition,\n      intersectionsDisconnect,\n      intersectionsConnect,\n      trimCradle,\n      fillCradle,\n      updateCurrentAxisReferenceID\n    }),\n    reset = (0, useReset_1.default)({\n      cradlePotentialRef,\n      portalContainerMapRef,\n      portalIDListRef,\n      cellPortalListRef,\n      cellDataListRef,\n      tailBandListRef,\n      headBandListRef,\n      cradleActualRef,\n      setPortalRenderList,\n      intersectionsDisconnect,\n      intersectionsConnect,\n      getSeed,\n      callbacksRef,\n      resetAxisPosition\n    }),\n    applyNewCradlePotential = (0, useNewCradlePotential_1.default)({\n      orientationRef,\n      layoutRef,\n      spacingRef,\n      seedReferenceIDRef,\n      currentAxisReferenceIDRef,\n      cradleActualRef,\n      cellPortalListRef,\n      portalIDListRef,\n      portalContainerMapRef,\n      headblockRef,\n      headBandListRef,\n      leadHeadblockBandRef,\n      tailblockRef,\n      tailBandListRef,\n      leadTailblockBandRef,\n      // callbacksRef,\n      intersectionsDisconnect,\n      intersectionsConnect,\n      setPortalRenderList,\n      removeCells,\n      getSeed,\n      fillCradle,\n      updateCurrentAxisReferenceID,\n      bandMutationObserverRef\n    }),\n    availableCalls = (0, useCalls_1.default)({\n      scrollerQueueRef,\n      scrollerName,\n      operationsRef,\n      portalIDListRef,\n      cellPortalListRef,\n      cellDataListRef,\n      portalContainerMapRef,\n      spacingRef,\n      scrollTopRef,\n      scrollLeftRef,\n      viewportRef,\n      headblockRef,\n      tailblockRef,\n      headBandListRef,\n      tailBandListRef,\n      leadHeadblockBandRef,\n      cradleActualRef,\n      cradlePotentialRef,\n      cellDimensionsRef,\n      orientationRef,\n      layoutRef,\n      currentAxisReferenceIDRef,\n      setPortalRenderList,\n      updateCurrentAxisReferenceID,\n      trimCradle,\n      fillCradle,\n      reset,\n      callbacksRef,\n      intersectionsDisconnect,\n      intersectionsConnect,\n      bandMutationObserverRef\n    });\n  // ==============================[ initialization effects ]========================\n  (0, react_1.useEffect)(() => {\n    return () => {\n      viewportRef.current && viewportRef.current.remove(); // abundance of caution\n    };\n  }, []);\n  // set spacing values\n  (0, react_1.useEffect)(() => {\n    cradleMarginsRef.current = (0, utilities_2.getCradleMarginsFromSpacing)(spacing);\n    bandPaddingRef.current = (0, utilities_2.getBandPaddingFromSpacing)(spacing);\n    cellGapRef.current = (0, utilities_2.getCellGapFromSpacing)(spacing);\n    spacingRef.current = {\n      cradleMargin: cradleMarginsRef.current,\n      bandPadding: bandPaddingRef.current,\n      cellGap: cellGapRef.current\n    };\n  }, [spacing]);\n  // set up IntersectionObserver, ResizeObserver and MutationObserver\n  (0, react_1.useEffect)(() => {\n    const iObserver = intersectionObserverRef.current = new IntersectionObserver(intersectionObserverCallback, {\n      root: viewportRef.current\n    });\n    const rObserver = resizeObserverRef.current = new ResizeObserver(resizeObserverCallback);\n    rObserver.observe(viewportRef.current);\n    return () => {\n      intersectionObserverRef.current.disconnect();\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n  // cradle position initialization\n  (0, react_1.useEffect)(() => {\n    if (orientationRef.current == 'vertical') {\n      viewportRef.current.scrollTo(scrollLeftRef.current, AXIS_START_POSITION);\n      setAxisPosition(0, AXIS_START_POSITION - 1, 'setup');\n    } else {\n      // 'horizontal'\n      viewportRef.current.scrollTo(AXIS_START_POSITION, scrollTopRef.current);\n      setAxisPosition(AXIS_START_POSITION - 1, 0);\n    }\n  }, []);\n  // return calls to host\n  (0, react_1.useEffect)(() => {\n    if (!calls) return;\n    Object.assign(calls, availableCalls);\n  }, [calls]);\n  // ===========================[ callbacks ]=========================\n  const intersectionObserverCallback = (0, react_1.useCallback)((entries, observer) => {\n    entries.sort((a, b) => {\n      return a.time - b.time; // ascending\n    });\n    entries.forEach(entry => {\n      if (orientationRef.current == 'vertical') {\n        entry.rs3position = entry.isIntersecting ? 'in' : entry.rootBounds.top > entry.boundingClientRect.bottom ? 'before' : 'after';\n      } else {\n        // 'horizontal'\n        entry.rs3position = entry.isIntersecting ? 'in' : entry.rootBounds.left > entry.boundingClientRect.right ? 'before' : 'after';\n      }\n      intersectionsMapRef.current.set(entry.target.dataset.type, entry);\n    });\n    evaluateIntersections('observer');\n  }, []);\n  const resizeObserverCallback = (0, react_1.useCallback)(entries => {\n    const viewportEntry = entries[0],\n      borderBox = viewportEntry.borderBoxSize[0],\n      width = borderBox.inlineSize,\n      height = borderBox.blockSize;\n    intersectionsDisconnect();\n    const timeout = scrollerState == 'setup' ? SHORT_MOMENTUM_FADE : STANDARD_SCROLL_MOMENTUM_FADE;\n    clearTimeout(resizeTimeoutIDRef.current);\n    resizeTimeoutIDRef.current = setTimeout(() => {\n      if (scrollerState == 'setup') {\n        setScrollerState('ready'); // measurements available\n      }\n      // console.log('setting viewportDimensions', scrollerName)\n      setViewportDimensions({\n        width,\n        height\n      });\n    }, timeout);\n  }, [scrollerState]);\n  // ======================[ events ]============================\n  // TODO reverse scroll direction should cancel immediateStopScrolling\n  const onViewportScroll = event => {\n    const {\n      target\n    } = event;\n    event.stopPropagation();\n    clearTimeout(scrollMomentumTimeoutIDRef.current);\n    if (immediateStopScrollingRef.current) {\n      target.scrollTo(scrollLeftRef.current, scrollTopRef.current);\n    } else {\n      scrollTopRef.current = target.scrollTop;\n      scrollLeftRef.current = target.scrollLeft;\n    }\n    if (!isScrollingMode) {\n      immediateIsScrollingRef.current = true;\n      setIsScrollingMode(true);\n    }\n    scrollMomentumTimeoutIDRef.current = setTimeout(() => {\n      setIsScrollingMode(false);\n    }, STANDARD_SCROLL_MOMENTUM_FADE);\n  };\n  // =========================[ reconfiguration effects ]=====================\n  (0, react_1.useEffect)(() => {\n    let cradleMutationObserver, bandMutationObserver;\n    if (operations.dispatchAttachedEvents) {\n      const event = new Event('rs3attached');\n      const cradleCallback = mutationList => {\n        mutationList.forEach(mutationRecord => {\n          mutationRecord.addedNodes.forEach(band => {\n            for (let index = 0; index < band.children.length; index++) {\n              const child = band.children[index];\n              child.firstChild && child.firstChild.dispatchEvent(event);\n            }\n          });\n        });\n      };\n      const bandCallback = mutationList => {\n        mutationList.forEach(mutationRecord => {\n          mutationRecord.addedNodes.forEach(node => {\n            node.firstChild && node.firstChild.dispatchEvent(event);\n          });\n        });\n      };\n      cradleMutationObserverRef.current = cradleMutationObserver = new MutationObserver(cradleCallback);\n      cradleMutationObserver.observe(headblockRef.current, {\n        childList: true\n      });\n      cradleMutationObserver.observe(leadHeadblockBandRef.current, {\n        childList: true\n      });\n      cradleMutationObserver.observe(tailblockRef.current, {\n        childList: true\n      });\n      cradleMutationObserver.observe(leadTailblockBandRef.current, {\n        childList: true\n      });\n      bandMutationObserverRef.current = bandMutationObserver = new MutationObserver(bandCallback);\n      const headBandList = headBandListRef.current,\n        tailBandList = tailBandListRef.current;\n      headBandList.forEach(band => {\n        bandMutationObserver.observe(band, {\n          childList: true\n        });\n      });\n      tailBandList.forEach(band => {\n        bandMutationObserver.observe(band, {\n          childList: true\n        });\n      });\n    } else {\n      cradleMutationObserverRef.current && cradleMutationObserverRef.current.disconnect();\n      bandMutationObserverRef.current && bandMutationObserverRef.current.disconnect();\n    }\n    return () => {\n      cradleMutationObserverRef.current && cradleMutationObserverRef.current.disconnect();\n      bandMutationObserverRef.current && bandMutationObserverRef.current.disconnect();\n    };\n  }, [operations.dispatchAttachedEvents]);\n  // configure cradlePotential on change of cellDimensions, viewportDimensions, orientation, layout or RUNWAY_BANDS\n  (0, react_1.useLayoutEffect)(() => {\n    if (!viewportDimensions) return; // setup\n    const [cradleMarginStart, cradleMarginEnd] = cradleMarginsRef.current,\n      cellGap = cellGapRef.current;\n    let cellsPerBand, visibleBands;\n    const cellMaxWidth = cellDimensions.maxWidth,\n      cellMaxHeight = cellDimensions.maxHeight,\n      cellMinWidth = cellDimensions.minWidth,\n      cellMinHeight = cellDimensions.minHeight,\n      // spacing = spacingRef.current,\n      [start, end] = spacingRef.current.bandPadding,\n      bandPadding = start + end;\n    if (orientation == 'vertical') {\n      cellsPerBand = Math.ceil((viewportDimensions.width - (cradleMarginStart + cradleMarginEnd) + cellGap) / (cellMaxWidth + cellGap));\n      if (layout == 'uniform') {\n        visibleBands = Math.ceil(viewportDimensions.height / (cellMaxHeight + bandPadding));\n      } else {\n        // 'variable'\n        visibleBands = Math.ceil(viewportDimensions.height / (cellMinHeight + bandPadding));\n      }\n    } else {\n      // 'horizontal'\n      cellsPerBand = Math.ceil((viewportDimensions.height - (cradleMarginStart + cradleMarginEnd) + cellGap) / (cellMaxHeight + cellGap));\n      if (layout == 'uniform') {\n        visibleBands = Math.ceil(viewportDimensions.width / (cellMaxWidth + bandPadding));\n      } else {\n        // 'variable'\n        visibleBands = Math.ceil(viewportDimensions.width / (cellMinWidth + bandPadding));\n      }\n    }\n    const runwayBands = RUNWAY_BANDS;\n    const totalBands = visibleBands + runwayBands * 2,\n      backwardBands = runwayBands,\n      forwardBands = totalBands - backwardBands,\n      forwardCells = forwardBands * cellsPerBand,\n      backwardCells = backwardBands * cellsPerBand,\n      totalCells = forwardCells + backwardCells;\n    const cradlePotential = {\n      orientation,\n      layout,\n      cellsPerBand,\n      visibleBands,\n      totalBands,\n      forwardBands,\n      backwardBands,\n      forwardCells,\n      backwardCells,\n      totalCells\n    };\n    if (cradleActualRef.current.cellsPerBand === null) {\n      cradleActualRef.current.cellsPerBand = cellsPerBand;\n    }\n    setStyles((0, orientationStyles_2.selectStyles)(orientation));\n    setCradlePotential(cradlePotential);\n  }, [orientation, layout, cellDimensions, spacing, viewportDimensions, RUNWAY_BANDS]);\n  // reconfigure cradle on change of cradlePotential\n  (0, react_1.useLayoutEffect)(() => {\n    if (!cradlePotential) return;\n    if (previousOrientationRef.current !== orientationRef.current || previousLayoutRef.current !== layoutRef.current || previousCellDimensionsRef.current !== cellDimensionsRef.current || previousSpacingRef.current !== spacingRef.current) {\n      previousOrientationRef.current = orientationRef.current;\n      previousLayoutRef.current = layoutRef.current;\n      previousCellDimensionsRef.current = cellDimensionsRef.current;\n      previousSpacingRef.current = spacingRef.current;\n      // prevent duplicate call from useEffect for seedRferenceID or fetchCells below\n      previousSeedReferenceIDRef.current = seedReferenceIDRef.current;\n      previousFetchCellsRef.current = fetchCellsRef.current;\n      scrollerQueueRef.current.enqueue(() => __awaiter(void 0, void 0, void 0, function* () {\n        yield reset(currentAxisReferenceIDRef.current);\n      }));\n    } else {\n      scrollerQueueRef.current.enqueue(() => __awaiter(void 0, void 0, void 0, function* () {\n        yield applyNewCradlePotential(cradlePotential);\n      }));\n    }\n  }, [cradlePotential]);\n  // TODO test to make sure this is not run after previous change\n  // reset based on new seedReferenceID or fetchCells\n  (0, react_1.useLayoutEffect)(() => {\n    if (scrollerStateRef.current == 'setup') return;\n    fetchCellsRef.current = fetchCells;\n    if (previousSeedReferenceIDRef.current === seedReferenceIDRef.current && previousFetchCellsRef.current === fetchCells) {\n      return;\n    }\n    const referenceIDSelection = previousSeedReferenceIDRef.current !== seedReferenceID ? seedReferenceID : currentAxisReferenceIDRef.current;\n    previousSeedReferenceIDRef.current = seedReferenceIDRef.current;\n    previousFetchCellsRef.current = fetchCellsRef.current;\n    scrollerQueueRef.current.enqueue(() => __awaiter(void 0, void 0, void 0, function* () {\n      yield reset(referenceIDSelection);\n    }));\n  }, [seedReferenceID, fetchCells]);\n  // ==============================[ scrolling adjustments ]===============================\n  (0, react_1.useLayoutEffect)(() => {\n    if (scrollerStateRef.current == 'setup') return;\n    if (!isScrollingMode) {\n      resetAxisPosition();\n      // reset scrolling control\n      immediateIsScrollingRef.current = false;\n    }\n  }, [isScrollingMode]);\n  // =============================[ render ]=======================\n  // the data-type values cannot be changed - the literals are used in code (to save intersection entries)\n  return react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(\"div\", {\n    \"data-type\": 'viewport',\n    \"data-scrollername\": scrollerName,\n    style: viewportStyles,\n    onScroll: onViewportScroll,\n    ref: viewportRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'scrollblock',\n    style: styles.scrollblockStyles,\n    ref: scrollblockRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'axis',\n    style: styles.axisStyles,\n    ref: axisRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'headblock',\n    style: styles.headblockStyles,\n    ref: headblockRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'headblock-overflow-trigger',\n    style: styles.headblockOverflowTriggerStyles,\n    ref: headblockOverflowTriggerRef\n  }), react_1.default.createElement(\"div\", {\n    \"data-type\": 'lead-headblock-band',\n    style: styles.leadHeadblockBandStyles,\n    ref: leadHeadblockBandRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'lead-headblock-band-backward-trigger',\n    style: styles.leadHeadblockBandBackwardTriggerStyles,\n    ref: leadHeadblockBandBackwardTriggerRef\n  }))), react_1.default.createElement(\"div\", {\n    \"data-type\": 'tailblock',\n    style: styles.tailblockStyles,\n    ref: tailblockRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'lead-tailblock-band',\n    style: styles.leadTailblockBandStyles,\n    ref: leadTailblockBandRef\n  }, react_1.default.createElement(\"div\", {\n    \"data-type\": 'lead-tailblock-band-forward-trigger',\n    style: styles.leadTailblockBandForwardTriggerStyles,\n    ref: leadTailblockBandStartTriggerRef\n  }), react_1.default.createElement(\"div\", {\n    \"data-type\": 'lead-tailblock-band-end-trigger',\n    style: styles.leadTailblockBandEndTriggerStyles,\n    ref: leadTailblockBandEndTriggerRef\n  })), react_1.default.createElement(\"div\", {\n    \"data-type\": 'tailblock-overflow-trigger',\n    style: styles.tailblockOverflowTriggerStyles,\n    ref: tailblockOverflowTriggerRef\n  }))))), react_1.default.createElement(\"div\", {\n    \"data-type\": 'virtual-cradle',\n    style: virtualCradleStyles\n  }, portalRenderList));\n}; // Viewport\n// the first five properties are required\nconst ReactSuperSimpleScroller = _a => {\n  var {\n      orientation,\n      layout,\n      cellDimensions,\n      seedReferenceID,\n      fetchCells\n    } = _a,\n    moreProperties = __rest(_a, [\"orientation\", \"layout\", \"cellDimensions\", \"seedReferenceID\", \"fetchCells\"]);\n  const {\n      callbacks,\n      calls,\n      spacing,\n      operations,\n      scrollerName\n    } = moreProperties,\n    properties = {\n      orientation,\n      layout,\n      cellDimensions,\n      seedReferenceID,\n      fetchCells,\n      callbacks,\n      calls,\n      spacing,\n      operations,\n      scrollerName\n    },\n    {\n      technical\n    } = moreProperties; // technical for internal constants\n  (0, react_1.useEffect)(() => {\n    var _a, _b, _c;\n    const techvalues = technical !== null && technical !== void 0 ? technical : {},\n      operationsvalues = operations !== null && operations !== void 0 ? operations : {};\n    STANDARD_SCROLL_MOMENTUM_FADE = (_a = techvalues.STANDARD_SCROLL_MOMENTUM_FADE) !== null && _a !== void 0 ? _a : DEFAULT_STANDARD_SCROLL_MOMENTUM_FADE;\n    SHORT_MOMENTUM_FADE = (_b = techvalues.SHORT_MOMENTUM_FADE) !== null && _b !== void 0 ? _b : DEFAULT_SHORT_MOMENTUM_FADE;\n    RUNWAY_BANDS = (_c = operations === null || operations === void 0 ? void 0 : operations.runway) !== null && _c !== void 0 ? _c : DEFAULT_RUNWAY_BANDS;\n  }, [technical]);\n  return react_1.default.createElement(Viewport, Object.assign({}, properties));\n};\nexports[\"default\"] = ReactSuperSimpleScroller;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/ReactSuperSimpleScroller.tsx?")},"./src/orientationStyles.tsx":(__unused_webpack_module,exports)=>{eval("\n\n// orientationStyles.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.selectStyles = exports.SCROLLBLOCK_SPAN = void 0;\nconst SCROLLBLOCK_SPAN = 1000000;\nexports.SCROLLBLOCK_SPAN = SCROLLBLOCK_SPAN;\n// --- vertical styles\nconst verticalScrollblockStyles = {\n  height: SCROLLBLOCK_SPAN + 'px',\n  width: '100%',\n  position: 'relative'\n};\nconst verticalAxisStyles = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  height: 0,\n  width: '100%'\n};\nconst verticalHeadblockStyles = {\n  zIndex: 0,\n  position: 'absolute',\n  left: 0,\n  bottom: 0,\n  width: 'fit-content',\n  minWidth: '100%',\n  display: 'flex',\n  flexDirection: 'column'\n};\nconst verticalHeadblockOverflowTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  height: '1px',\n  width: '100%'\n};\nconst verticalLeadHeadblockBandStyles = {\n  zIndex: 0,\n  position: 'relative',\n  minHeight: '1px',\n  minWidth: '100%'\n};\nconst verticalLeadHeadblockBandBackwardTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  height: '1px',\n  width: '100%'\n};\nconst verticalTailblockStyles = {\n  zIndex: 0,\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: 'fit-content',\n  minWidth: '100%',\n  display: 'flex',\n  flexDirection: 'column'\n};\nconst verticalTailblockOverflowTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  bottom: '-4px',\n  // PIXEL\n  right: 0,\n  height: '1px',\n  width: '100%'\n};\nconst verticalLeadTailblockBandStyles = {\n  zIndex: 0,\n  position: 'relative',\n  minHeight: '1px',\n  minWidth: '100%'\n};\nconst verticalLeadTailblockBandForwardTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  top: '5px',\n  right: 0,\n  height: '1px',\n  width: '100%'\n};\nconst verticalLeadTailblockBandEndTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  bottom: 0,\n  right: 0,\n  height: '1px',\n  width: '100%'\n};\n// --- horizontal styles\nconst horizontalScrollblockStyles = {\n  width: SCROLLBLOCK_SPAN + 'px',\n  height: '100%',\n  position: 'relative'\n};\nconst horizontalAxisStyles = {\n  position: 'absolute',\n  left: 0,\n  top: 0,\n  // bottom: 0,\n  width: 0,\n  height: '100%'\n};\nconst horizontalHeadblockStyles = {\n  zIndex: 0,\n  position: 'absolute',\n  top: 0,\n  // bottom: 0,\n  right: 0,\n  height: 'fit-content',\n  minHeight: '100%',\n  display: 'flex',\n  flexDirection: 'row'\n};\nconst horizontalHeadblockOverflowTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  left: 0,\n  top: 0,\n  // bottom:0,\n  height: '100%',\n  width: '1px'\n};\nconst horizontalLeadHeadblockBandStyles = {\n  zIndex: 0,\n  position: 'relative',\n  minWidth: '1px',\n  minHeight: '100%'\n};\nconst horizontalLeadHeadblockBandBackwardTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  left: 0,\n  top: 0,\n  // bottom: 0,\n  height: '100%',\n  width: '1px'\n};\nconst horizontalTailblockStyles = {\n  zIndex: 0,\n  position: 'absolute',\n  left: 0,\n  top: 0,\n  // bottom: 0,\n  height: 'fit-content',\n  minHeight: '100%',\n  display: 'flex',\n  flexDirection: 'row'\n};\nconst horizontalTailblockOverflowTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  right: '-4px',\n  top: 0,\n  height: '100%',\n  width: '1px'\n};\nconst horizontalLeadTailblockBandStyles = {\n  zIndex: 0,\n  position: 'relative',\n  minWidth: '1px',\n  minHeight: '100%'\n};\nconst horizontalLeadTailblockBandForwardTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  height: '100%',\n  width: '1px'\n};\nconst horizontalLeadTailblockBandEndTriggerStyles = {\n  zIndex: -1,\n  position: 'absolute',\n  top: 0,\n  right: 0,\n  height: '100%',\n  width: '1px'\n};\nconst selectStyles = orientation => {\n  // const [cradleMarginStart, cradleMarginEnd] = cradleMargins\n  let styles;\n  if (orientation == 'vertical') {\n    styles = {\n      scrollblockStyles: verticalScrollblockStyles,\n      axisStyles: verticalAxisStyles,\n      headblockStyles: verticalHeadblockStyles,\n      leadHeadblockBandStyles: verticalLeadHeadblockBandStyles,\n      headblockOverflowTriggerStyles: verticalHeadblockOverflowTriggerStyles,\n      leadHeadblockBandBackwardTriggerStyles: verticalLeadHeadblockBandBackwardTriggerStyles,\n      tailblockStyles: verticalTailblockStyles,\n      leadTailblockBandStyles: verticalLeadTailblockBandStyles,\n      tailblockOverflowTriggerStyles: verticalTailblockOverflowTriggerStyles,\n      leadTailblockBandForwardTriggerStyles: verticalLeadTailblockBandForwardTriggerStyles,\n      leadTailblockBandEndTriggerStyles: verticalLeadTailblockBandEndTriggerStyles\n    };\n  } else {\n    // horizontal\n    styles = {\n      scrollblockStyles: horizontalScrollblockStyles,\n      axisStyles: horizontalAxisStyles,\n      headblockStyles: horizontalHeadblockStyles,\n      leadHeadblockBandStyles: horizontalLeadHeadblockBandStyles,\n      headblockOverflowTriggerStyles: horizontalHeadblockOverflowTriggerStyles,\n      leadHeadblockBandBackwardTriggerStyles: horizontalLeadHeadblockBandBackwardTriggerStyles,\n      tailblockStyles: horizontalTailblockStyles,\n      leadTailblockBandStyles: horizontalLeadTailblockBandStyles,\n      tailblockOverflowTriggerStyles: horizontalTailblockOverflowTriggerStyles,\n      leadTailblockBandForwardTriggerStyles: horizontalLeadTailblockBandForwardTriggerStyles,\n      leadTailblockBandEndTriggerStyles: horizontalLeadTailblockBandEndTriggerStyles\n    };\n  }\n  return styles;\n};\nexports.selectStyles = selectStyles;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/orientationStyles.tsx?")},"./src/useCalls.tsx":function(__unused_webpack_module,exports,__webpack_require__){eval("\n\n// useCalls.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nconst react_dom_1 = __webpack_require__(/*! react-dom */ \"react-dom\");\nconst utilities_1 = __webpack_require__(/*! ./utilities */ \"./src/utilities.tsx\");\n/*\n    - calls available to host\n    has,\n    insert,\n    remove,\n    move,\n    replace,\n    getCradleIDList,\n    getCradleSpecs,\n    fetchCradleCells,\n    restoreScrollPositions,\n*/\nconst useCalls = ({\n  scrollerQueueRef,\n  scrollerName,\n  operationsRef,\n  portalIDListRef,\n  cellPortalListRef,\n  cellDataListRef,\n  portalContainerMapRef,\n  spacingRef,\n  scrollTopRef,\n  scrollLeftRef,\n  viewportRef,\n  headblockRef,\n  tailblockRef,\n  headBandListRef,\n  tailBandListRef,\n  leadHeadblockBandRef,\n  cradleActualRef,\n  cradlePotentialRef,\n  cellDimensionsRef,\n  orientationRef,\n  layoutRef,\n  currentAxisReferenceIDRef,\n  setPortalRenderList,\n  updateCurrentAxisReferenceID,\n  trimCradle,\n  fillCradle,\n  reset,\n  callbacksRef,\n  intersectionsDisconnect,\n  intersectionsConnect,\n  bandMutationObserverRef\n}) => {\n  var _a;\n  const callbacks = (_a = callbacksRef.current) !== null && _a !== void 0 ? _a : {};\n  const insert = (cellPack_1, targetReferenceID_1, ...args_1) => __awaiter(void 0, [cellPack_1, targetReferenceID_1, ...args_1], void 0, function* (cellPack, targetReferenceID, position = 'before') {\n    if (!(typeof cellPack == 'object' && react_1.default.isValidElement(cellPack.component) && (0, utilities_1.isValidID)(cellPack.id))) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'insert',\n          message: 'insert must have a valid cellPack argument',\n          arguments: [cellPack, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!(0, utilities_1.isValidID)(targetReferenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'insert',\n          message: 'insert targetReferenceID must be a valid ID',\n          arguments: [cellPack, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!['before', 'after'].includes(position)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'insert',\n          message: 'insert position must be either \"before\" or \"after\"',\n          arguments: [cellPack, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (portalContainerMapRef.current.has(cellPack.id)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'insert',\n          message: 'insert error: cellPack.id is already in the cradle',\n          arguments: [cellPack, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false; // aleady included\n    }\n    const targetPos = portalIDListRef.current.indexOf(targetReferenceID);\n    if (targetPos === -1) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'insert',\n          message: 'target id is not in the cradle',\n          arguments: [cellPack, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false; // no target for positioning\n    }\n    intersectionsDisconnect();\n    const cradleActual = cradleActualRef.current,\n      portalIDList = portalIDListRef.current,\n      cellDataList = cellDataListRef.current,\n      portalContainerMap = portalContainerMapRef.current,\n      cellPortalList = cellPortalListRef.current;\n    // --- calculate insert position\n    const insertPos = position == 'before' ? targetPos : targetPos + 1;\n    if (targetPos < cradleActual.backwardCells) {\n      cradleActual.backwardCells++;\n    } else {\n      cradleActual.forwardCells++;\n    }\n    // --- insert new cell data into lists\n    cellDataList.splice(insertPos, 0, cellPack);\n    portalIDList.splice(insertPos, 0, cellPack.id);\n    // --- create new container and portal\n    const newContainer = (0, utilities_1.createContainer)(cellPack.id, cellDimensionsRef.current, cradleActual.cellsPerBand, orientationRef.current, layoutRef.current);\n    portalContainerMap.set(cellPack.id, newContainer);\n    const newPortal = (0, react_dom_1.createPortal)(cellPack.component, newContainer, cellPack.id);\n    cellPortalList.splice(insertPos, 0, newPortal);\n    // --- push containers forward from insert point to make room for insert container\n    const {\n        cellsPerBand\n      } = cradleActual,\n      targetContainer = portalContainerMap.get(targetReferenceID);\n    if (targetPos <= cradleActual.backwardCells - 1) {\n      // adjust head bands\n      // --- adjust head bands\n      const headBandList = headBandListRef.current,\n        firstHeadbandOffset = cellsPerBand - headBandList[0].childElementCount,\n        targetHeadPos = targetPos,\n        // to be consistent with tail procesing\n        targetBandIndex = Math.ceil((targetHeadPos + firstHeadbandOffset + 1) / cellsPerBand) - 1,\n        firstBand = headBandList[0];\n      // create a first band if necessary to receive the outer displacement\n      if (firstBand.childElementCount === cellsPerBand) {\n        // first band is full\n        const newBand = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n        headblockRef.current.prepend(newBand);\n        headBandList.unshift(newBand);\n        cradleActual.backwardBands++;\n        cradleActual.totalBands++;\n      }\n      if (position == 'before') {\n        targetContainer.before(newContainer);\n      } else {\n        // 'after'\n        targetContainer.after(newContainer);\n      }\n      // --- shift containers\n      for (let bandindex = 0; bandindex < targetBandIndex; bandindex++) {\n        headBandList[bandindex].append(headBandList[bandindex + 1].firstChild);\n      }\n    } else {\n      // --- adjust tail bands\n      const tailBandList = tailBandListRef.current,\n        firstTailbandOffset = cellsPerBand - tailBandList[0].childElementCount,\n        tailPos = portalIDList.length - cradleActual.forwardCells,\n        targetTailPos = targetPos - tailPos,\n        targetBandIndex = Math.ceil((targetTailPos + firstTailbandOffset + 1) / cellsPerBand) - 1,\n        lastBand = tailBandList.at(-1);\n      // create a last band if necessary to receive the outer displacement\n      if (lastBand.childElementCount === cellsPerBand) {\n        // last band is full\n        const newBand = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n        tailblockRef.current.append(newBand);\n        tailBandList.push(newBand);\n        cradleActual.forwardBands++;\n        cradleActual.totalBands++;\n      }\n      if (position == 'before') {\n        targetContainer.before(newContainer);\n      } else {\n        // 'after'\n        targetContainer.after(newContainer);\n      }\n      // --- shift containers\n      for (let bandindex = tailBandList.length - 1; bandindex > targetBandIndex; bandindex--) {\n        tailBandList[bandindex].prepend(tailBandList[bandindex - 1].lastChild);\n      }\n    } // end of adjust tail bands\n    setPortalRenderList([...cellPortalListRef.current]);\n    trimCradle();\n    setTimeout(() => {\n      intersectionsConnect();\n    }, 1);\n    updateCurrentAxisReferenceID();\n    return true;\n  });\n  const remove = targetReferenceID => __awaiter(void 0, void 0, void 0, function* () {\n    if (!(0, utilities_1.isValidID)(targetReferenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'remove',\n          message: 'must be valid target referenceID',\n          arguments: [targetReferenceID],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    const targetPos = portalIDListRef.current.indexOf(targetReferenceID);\n    if (targetPos === -1) {\n      if (callbacks.warning) {\n        callbacks.warning({\n          source: 'remove',\n          message: 'target referenceID not found',\n          arguments: [targetReferenceID],\n          timestamp: Date.now()\n        });\n      }\n      return false; // no remove target in cradle\n    }\n    intersectionsDisconnect();\n    const portalIDList = portalIDListRef.current,\n      cellPortalList = cellPortalListRef.current,\n      cellDataList = cellDataListRef.current,\n      cradleActual = cradleActualRef.current,\n      {\n        cellsPerBand\n      } = cradleActual,\n      portalContainerMap = portalContainerMapRef.current,\n      targetContainer = portalContainerMap.get(targetReferenceID);\n    if (targetPos < cradleActual.backwardCells) {\n      // shift backward containers\n      const headBandList = headBandListRef.current,\n        firstHeadBandOffset = cellsPerBand - headBandList[0].childElementCount,\n        targetHeadPos = targetPos,\n        targetBandIndex = Math.ceil((targetHeadPos + firstHeadBandOffset + 1) / cellsPerBand) - 1,\n        targetBand = headBandList[targetBandIndex];\n      for (let bandIndex = targetBandIndex; bandIndex > 0; bandIndex--) {\n        headBandList[bandIndex].prepend(headBandList[bandIndex - 1].lastChild);\n      }\n      const workingBand = headBandList[0];\n      if (workingBand.childElementCount === 0) {\n        workingBand.remove();\n        headBandList.unShift();\n        cradleActual.headBands--;\n        cradleActual.totalBands--;\n      }\n      cradleActual.backwardCells--;\n    } else {\n      // shift forward containers\n      const tailBandList = tailBandListRef.current,\n        firstTailBandOffset = cellsPerBand - tailBandList[0].childElementCount,\n        tailPos = portalIDList.length - cradleActual.forwardCells,\n        targetTailPos = targetPos - tailPos,\n        targetBandIndex = Math.ceil((targetTailPos + firstTailBandOffset + 1) / cellsPerBand) - 1;\n      for (let bandIndex = targetBandIndex; bandIndex < tailBandList.length - 1; bandIndex++) {\n        tailBandList[bandIndex].append(tailBandList[bandIndex + 1].firstChild);\n      }\n      const lastTailBand = tailBandList.at(-1);\n      if (lastTailBand.childElementCount === 0) {\n        lastTailBand.remove();\n        tailBandList.pop();\n        cradleActual.tailBands--;\n        cradleActual.totalBands--;\n      }\n      cradleActual.forwardCells--;\n    }\n    targetContainer.remove();\n    portalContainerMap.delete(targetReferenceID);\n    portalIDList.splice(targetPos, 1);\n    cellPortalList.splice(targetPos, 1);\n    cellDataList.splice(targetPos, 1);\n    cradleActual.totalCells--;\n    setPortalRenderList([...cellPortalListRef.current]);\n    yield fillCradle();\n    setTimeout(() => {\n      intersectionsConnect();\n    }, 1);\n    updateCurrentAxisReferenceID();\n    callbacks.removed && callbacks.removed([targetReferenceID]);\n    return true;\n  });\n  const move = (sourceReferenceID_1, targetReferenceID_1, ...args_1) => __awaiter(void 0, [sourceReferenceID_1, targetReferenceID_1, ...args_1], void 0, function* (sourceReferenceID, targetReferenceID, position = 'before') {\n    // parameter validation\n    if (!(0, utilities_1.isValidID)(sourceReferenceID) || !(0, utilities_1.isValidID)(targetReferenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'move',\n          message: 'both source and target must be valid referenceIDs',\n          arguments: [sourceReferenceID, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!['before', 'after'].includes(position)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'move',\n          message: 'position must be \"before\" or \"after\"',\n          arguments: [sourceReferenceID, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (sourceReferenceID === targetReferenceID) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'move',\n          message: 'source and target referenceIDs cannot be equal',\n          arguments: [sourceReferenceID, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    const portalContainerMap = portalContainerMapRef.current;\n    if (!portalContainerMap.has(sourceReferenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'move',\n          message: 'source referenceID not found in cradle',\n          arguments: [sourceReferenceID, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!portalContainerMap.has(targetReferenceID)) {\n      if (callbacks.warning) {\n        callbacks.warning({\n          source: 'move',\n          message: 'targetReferenceID not found in cradle. sourceReferenceID being removed',\n          arguments: [sourceReferenceID, targetReferenceID, position],\n          timestamp: Date.now()\n        });\n      }\n      remove(sourceReferenceID);\n      return true;\n    }\n    intersectionsDisconnect();\n    // common data\n    const cradleActual = cradleActualRef.current,\n      {\n        cellsPerBand\n      } = cradleActual,\n      portalIDList = portalIDListRef.current,\n      cellDataList = cellDataListRef.current,\n      cellPortalList = cellPortalListRef.current,\n      sourcePos = portalIDList.indexOf(sourceReferenceID),\n      targetPos = portalIDList.indexOf(targetReferenceID),\n      tailPos = portalIDList.length - cradleActual.forwardCells,\n      sourceLocation = 's' + (sourcePos < tailPos ? 'h' : 't'),\n      targetLocation = 't' + (targetPos < tailPos ? 'h' : 't'),\n      moveSpread = Math.abs(sourcePos - targetPos),\n      sourceContainer = portalContainerMap.get(sourceReferenceID),\n      targetContainer = portalContainerMap.get(targetReferenceID);\n    // avoid unnecessary processing\n    if (moveSpread === 1) {\n      if (sourcePos > targetPos && position == 'after' || targetPos > sourcePos && position == 'before') {\n        return true; // move would have no effect\n      }\n    }\n    // processing control\n    const comboLocation = sourceLocation + targetLocation;\n    // move container according to comboLocation\n    if (comboLocation == 'shth') {\n      // all in head\n      const headBandList = headBandListRef.current,\n        firstHeadBandOffset = cellsPerBand - headBandList[0].childElementCount,\n        sourceHeadPos = sourcePos,\n        // for consistency with tail processing\n        targetHeadPos = targetPos,\n        sourceBandIndex = Math.ceil((sourceHeadPos + firstHeadBandOffset + 1) / cellsPerBand) - 1,\n        targetBandIndex = Math.ceil((targetHeadPos + firstHeadBandOffset + 1) / cellsPerBand) - 1;\n      if (position == 'after') {\n        targetContainer.after(sourceContainer);\n      } else {\n        // 'before'\n        targetContainer.before(sourceContainer);\n      }\n      if (sourceBandIndex < targetBandIndex) {\n        for (let bandIndex = targetBandIndex; bandIndex > sourceBandIndex; bandIndex--) {\n          headBandList[bandIndex - 1].append(headBandList[bandIndex].firstChild);\n        }\n      } else if (sourceBandIndex > targetBandIndex) {\n        for (let bandIndex = targetBandIndex; bandIndex < sourceBandIndex; bandIndex++) {\n          headBandList[bandIndex + 1].prepend(headBandList[bandIndex].lastChild);\n        }\n      } // else changed in current band only\n    } else if (comboLocation == 'sttt') {\n      // all in tail\n      const tailBandList = tailBandListRef.current,\n        firstTailBandOffset = cellsPerBand - tailBandList[0].childElementCount,\n        sourceTailPos = sourcePos - tailPos,\n        targetTailPos = targetPos - tailPos,\n        sourceBandIndex = Math.ceil((sourceTailPos + firstTailBandOffset + 1) / cellsPerBand) - 1,\n        targetBandIndex = Math.ceil((targetTailPos + firstTailBandOffset + 1) / cellsPerBand) - 1;\n      if (position == 'after') {\n        targetContainer.after(sourceContainer);\n      } else {\n        // 'before'\n        targetContainer.before(sourceContainer);\n      }\n      if (sourceBandIndex > targetBandIndex) {\n        for (let bandIndex = targetBandIndex; bandIndex < sourceBandIndex; bandIndex++) {\n          tailBandList[bandIndex + 1].prepend(tailBandList[bandIndex].lastChild);\n        }\n      } else if (sourceBandIndex < targetBandIndex) {\n        for (let bandIndex = targetBandIndex; bandIndex > sourceBandIndex; bandIndex--) {\n          tailBandList[bandIndex - 1].append(tailBandList[bandIndex].firstChild);\n        }\n      } // else changed in current band only\n    } else if (sourceLocation == 'sh') {\n      // sourceLocation -- head; targetLocation == 'tt' -- tail\n      const headBandList = headBandListRef.current,\n        firstHeadBandOffset = cellsPerBand - headBandList[0].childElementCount,\n        sourceHeadPos = sourcePos,\n        sourceBandIndex = Math.ceil((sourceHeadPos + firstHeadBandOffset + 1) / cellsPerBand) - 1,\n        tailBandList = tailBandListRef.current,\n        targetTailPos = targetPos - tailPos,\n        targetBandIndex = Math.ceil((targetTailPos + 1) / cellsPerBand) - 1;\n      if (position == 'after') {\n        targetContainer.after(sourceContainer);\n      } else {\n        // 'before'\n        targetContainer.before(sourceContainer);\n      }\n      // process head band for removal of a container\n      for (let bandIndex = sourceBandIndex; bandIndex > 0; bandIndex--) {\n        headBandList[bandIndex].prepend(headBandList[bandIndex - 1].lastChild);\n      }\n      // remove empty band if necessary\n      const workingHeadBand = headBandList[0];\n      if (workingHeadBand.childElementCount === 0) {\n        workingHeadBand.remove();\n        headBandList.shift();\n        cradleActual.headBands--;\n        cradleActual.totalBands--;\n      }\n      // process tail band for addition of a container\n      for (let bandIndex = targetBandIndex; bandIndex < tailBandList.length - 1; bandIndex++) {\n        tailBandList[bandIndex + 1].prepend(tailBandList[bandIndex].lastChild);\n      }\n      // add new band if necessary\n      const workingTailBand = tailBandList.at(-1);\n      if (workingTailBand.childElementCount > cellsPerBand) {\n        const newBand = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n        newBand.prepend(workingTailBand.lastChild);\n        tailblockRef.current.append(newBand);\n        tailBandList.push(newBand);\n        cradleActual.tailBands++;\n        cradleActual.totalBands++;\n      }\n      cradleActual.backwardCells--;\n      cradleActual.forwardCells++;\n    } else {\n      // sourceLocation == 'st' -- tail ; targetLocation == 'th' -- head\n      // move sourceContainer, then expand head and compact tail\n      const headBandList = headBandListRef.current,\n        firstHeadBandOffset = cellsPerBand - headBandList[0].childElementCount,\n        targetHeadPos = targetPos,\n        targetBandIndex = Math.ceil((targetHeadPos + firstHeadBandOffset + 1) / cellsPerBand) - 1,\n        tailBandList = tailBandListRef.current,\n        sourceTailPos = sourcePos - tailPos,\n        sourceBandIndex = Math.ceil((sourceTailPos + 1) / cellsPerBand) - 1;\n      // console.log('sourceContainer, targetContainer',sourceContainer, targetContainer)\n      if (position == 'after') {\n        targetContainer.after(sourceContainer);\n      } else {\n        // 'before'\n        targetContainer.before(sourceContainer);\n      }\n      // process tail band for removal of a container\n      for (let bandIndex = sourceBandIndex; bandIndex < tailBandList.length - 1; bandIndex++) {\n        tailBandList[bandIndex].append(tailBandList[bandIndex + 1].firstChild);\n      }\n      // remove empty from tail band if necessary\n      const workingTailBand = tailBandList.at(-1);\n      if (workingTailBand.childElementCount === 0) {\n        workingTailBand.remove();\n        tailBandList.pop();\n        cradleActual.tailBands--;\n        cradleActual.totalBands--;\n      }\n      // process head band for addition of a container\n      for (let bandIndex = targetBandIndex; bandIndex > 0; bandIndex--) {\n        headBandList[bandIndex - 1].prepend(headBandList[bandIndex].lastChild);\n      }\n      // add new band if necessary\n      const workingHeadBand = headBandList[0];\n      if (workingHeadBand.childElementCount > cellsPerBand) {\n        const newBand = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n        newBand.append(workingHeadBand.firstChild);\n        headblockRef.current.prepend(newBand);\n        headBandList.unshift(newBand);\n        cradleActual.headBands++;\n        cradleActual.totalBands++;\n      }\n      cradleActual.backwardCells++;\n      cradleActual.forwardCells--;\n    }\n    // update internal structures\n    const insertPos = position == 'before' ? targetPos : targetPos + 1;\n    if (sourcePos > targetPos) {\n      const [id] = portalIDList.splice(sourcePos, 1),\n        [portal] = cellPortalList.splice(sourcePos, 1),\n        [data] = cellDataList.splice(sourcePos, 1);\n      portalIDList.splice(insertPos, 0, id);\n      cellPortalList.splice(insertPos, 0, portal);\n      cellDataList.splice(insertPos, 0, data);\n    } else {\n      // sourcePos < targetPos\n      const [id] = portalIDList.slice(sourcePos, sourcePos + 1),\n        [portal] = cellPortalList.slice(sourcePos, sourcePos + 1),\n        [data] = cellDataList.slice(sourcePos, sourcePos + 1);\n      portalIDList.splice(insertPos, 0, id);\n      cellPortalList.splice(insertPos, 0, portal);\n      cellDataList.splice(insertPos, 0, data);\n      portalIDList.splice(sourcePos, 1);\n      cellPortalList.splice(sourcePos, 1);\n      cellDataList.splice(sourcePos, 1);\n    }\n    // update presentation\n    setPortalRenderList([...cellPortalListRef.current]);\n    trimCradle();\n    yield fillCradle();\n    setTimeout(() => {\n      intersectionsConnect();\n    }, 1);\n    updateCurrentAxisReferenceID();\n    return true;\n  });\n  const getCradleIDList = () => {\n    return [...portalIDListRef.current];\n  };\n  const getCradleSpecs = () => {\n    const specs = {\n      cradleActual: Object.assign({\n        scrollerName,\n        firstReferenceID: portalIDListRef.current[0],\n        lastReferenceID: portalIDListRef.current.at(-1),\n        axisReferenceID: currentAxisReferenceIDRef.current\n      }, cradleActualRef.current),\n      cradlePotential: Object.assign({\n        cellDimensions: Object.assign({}, cellDimensionsRef.current),\n        spacing: Object.assign({}, spacingRef.current)\n      }, cradlePotentialRef.current)\n    };\n    return specs;\n  };\n  const fetchCradleCells = seedReferenceID => __awaiter(void 0, void 0, void 0, function* () {\n    if (seedReferenceID != null) {\n      scrollerQueueRef.current.enqueue(() => __awaiter(void 0, void 0, void 0, function* () {\n        yield reset(seedReferenceID);\n      }));\n    } else {\n      intersectionsDisconnect();\n      yield fillCradle();\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n    }\n  });\n  const restoreScrollPositions = () => {\n    const event = new Event('rs3attached');\n    intersectionsDisconnect();\n    viewportRef.current.scrollTo(scrollLeftRef.current, scrollTopRef.current);\n    setTimeout(() => {\n      intersectionsConnect();\n    }, 1);\n    operationsRef.current.dispatchAttachedEvents && portalContainerMapRef.current.forEach(container => {\n      container.firstChild && container.firstChild.dispatchEvent(event);\n    });\n  };\n  const has = referenceID => {\n    if (!(0, utilities_1.isValidID)(referenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'has',\n          message: 'must be a valid referenceID',\n          arguments: [referenceID],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    return portalContainerMapRef.current.has(referenceID);\n  };\n  const replace = (referenceID, cellPack = {\n    id: null,\n    component: null,\n    default: true\n  }) => {\n    const portalIDList = portalIDListRef.current,\n      cellPortalList = cellPortalListRef.current,\n      cellDataList = cellDataListRef.current,\n      portalContainerMap = portalContainerMapRef.current,\n      cradlePotential = cradlePotentialRef.current,\n      cellDimensions = cellDimensionsRef.current;\n    if (!(0, utilities_1.isValidID)(referenceID)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'replace',\n          message: 'must be a valid referenceID',\n          arguments: [referenceID, cellPack],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!(0, utilities_1.isValidID)(cellPack.id)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'replace',\n          message: 'must be a valid cellPack.id',\n          arguments: [referenceID, cellPack],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!react_1.default.isValidElement(cellPack.component)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'replace',\n          message: 'must be a valid cellPack.component',\n          arguments: [referenceID, cellPack],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (!portalContainerMap.has(referenceID)) {\n      if (callbacks.warning) {\n        callbacks.warning({\n          source: 'replace',\n          message: 'referenceID not found',\n          arguments: [referenceID, cellPack],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    if (portalContainerMap.has(cellPack.id)) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'replace',\n          message: 'cellPack.id already in cradle',\n          arguments: [referenceID, cellPack],\n          timestamp: Date.now()\n        });\n      }\n      return false;\n    }\n    const {\n        cellsPerBand,\n        orientation,\n        layout\n      } = cradlePotential,\n      newContainer = (0, utilities_1.createContainer)(cellPack.id, cellDimensions, cellsPerBand, orientation, layout),\n      oldContainer = portalContainerMap.get(referenceID),\n      newPortal = (0, react_dom_1.createPortal)(cellPack.component, newContainer, cellPack.id),\n      newID = cellPack.id;\n    const arrayIndex = portalIDList.findIndex(value => referenceID === value);\n    portalIDList[arrayIndex] = newID;\n    cellPortalList[arrayIndex] = newPortal;\n    cellDataList[arrayIndex] = cellPack;\n    portalContainerMap.delete(referenceID);\n    portalContainerMap.set(newID, newContainer);\n    oldContainer.before(newContainer);\n    oldContainer.remove();\n    setPortalRenderList([...cellPortalList]);\n    updateCurrentAxisReferenceID();\n    return true;\n  };\n  const calls = {\n    has,\n    insert,\n    remove,\n    move,\n    replace,\n    getCradleIDList,\n    getCradleSpecs,\n    fetchCradleCells,\n    restoreScrollPositions\n  };\n  return calls;\n};\nexports[\"default\"] = useCalls;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/useCalls.tsx?")},"./src/useCells.tsx":function(__unused_webpack_module,exports,__webpack_require__){eval("\n\n// useCells.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nconst react_dom_1 = __webpack_require__(/*! react-dom */ \"react-dom\");\nconst utilities_1 = __webpack_require__(/*! ./utilities */ \"./src/utilities.tsx\");\nconst useCells = ({\n  scrollerName,\n  orientationRef,\n  layoutRef,\n  spacingRef,\n  cradlePotentialRef,\n  cradleActualRef,\n  cellPortalListRef,\n  portalIDListRef,\n  cellDataListRef,\n  portalContainerMapRef,\n  cellDimensionsRef,\n  tailblockRef,\n  tailBandListRef,\n  leadTailblockBandRef,\n  headblockRef,\n  headBandListRef,\n  leadHeadblockBandRef,\n  setPortalRenderList,\n  fetchCellsRef,\n  updateCurrentAxisReferenceID,\n  callbacksRef,\n  bandMutationObserverRef\n}) => {\n  var _a;\n  const callbacks = (_a = callbacksRef.current) !== null && _a !== void 0 ? _a : {};\n  // call 'seed' or 'forward', never 'backward' (called by forward)\n  const getCells = (direction_1, ...args_1) => __awaiter(void 0, [direction_1, ...args_1], void 0, function* (direction, seedReferenceID = null) {\n    if (!tailblockRef.current || !headblockRef.current) return;\n    const cradlePotential = cradlePotentialRef.current,\n      cradleActual = cradleActualRef.current,\n      fetchCells = fetchCellsRef.current;\n    if (!cradlePotential) return; // uninitialized\n    if (direction == 'seed') {\n      const count = 1,\n        newCells = yield fetchCells(direction, seedReferenceID, count);\n      if (newCells.length > count) {\n        const excess = newCells.splice(count);\n        if (excess.length) {\n          const excessIDList = excess.map(cellPack => cellPack.id);\n          callbacks.failed && callbacks.failed({\n            source: 'fetchCells, seed',\n            message: 'too many cellPacks; excess not loaded',\n            excessList: excessIDList,\n            timestamp: Date.now()\n          });\n        }\n      }\n      if (newCells.length) {\n        const newPortalList = setSeedCell(newCells);\n        cellPortalListRef.current = newPortalList;\n        setPortalRenderList(newPortalList);\n        updateCurrentAxisReferenceID();\n      }\n      yield getCells('forward');\n    } else if (direction == 'forward') {\n      const tailBandList = tailBandListRef.current;\n      let offset = 0;\n      if (tailBandList.length > 1) {\n        offset = cradleActual.cellsPerBand - tailBandList[0].childElementCount;\n      }\n      let moreExpected = true;\n      while (cradleActual.forwardCells < cradlePotential.forwardCells - offset && moreExpected) {\n        const count = cradlePotential.forwardCells - cradleActual.forwardCells;\n        let newCells = [];\n        if (count > 0) {\n          newCells = yield fetchCells(direction, portalIDListRef.current.at(-1), count);\n        }\n        if (newCells.length > count) {\n          const excess = newCells.splice(count);\n          if (excess.length) {\n            const excessIDList = excess.map(cellPack => cellPack.id);\n            callbacks.failed && callbacks.failed({\n              source: 'fetchCells, forward',\n              message: 'too many cellPacks; excess not loaded',\n              excessList: excessIDList,\n              timestamp: Date.now()\n            });\n          }\n        }\n        if (!newCells.length) {\n          moreExpected = false;\n        } else {\n          const newPortalList = setForwardCells(newCells);\n          if (newPortalList.length === cellPortalListRef.current.length) {\n            // something went wrong\n            if (callbacks.error) {\n              callbacks.error({\n                source: 'fetchCells, forward',\n                message: 'one or more errors found in fetched cellPacks. Loading aborted',\n                arguments: [direction, portalIDListRef.current.at(-1), count],\n                return: newCells,\n                timestamp: Date.now()\n              });\n            }\n            break;\n          }\n          cellPortalListRef.current = newPortalList;\n          setPortalRenderList(newPortalList);\n          updateCurrentAxisReferenceID();\n        }\n      }\n      yield getCells('backward');\n    } else if (direction == 'backward') {\n      let moreExpected = true;\n      while (cradleActual.backwardCells < cradlePotential.backwardCells && moreExpected) {\n        const count = cradlePotential.backwardCells - cradleActual.backwardCells;\n        let newCells = [];\n        if (count > 0) {\n          newCells = yield fetchCells(direction, portalIDListRef.current[0], count);\n        }\n        if (newCells.length > count) {\n          const excess = newCells.splice(count);\n          if (excess.length) {\n            const excessIDList = excess.map(cellPack => cellPack.id);\n            callbacks.failed && callbacks.failed({\n              source: 'fetchCells, backward',\n              message: 'too many cellPacks; excess not loaded',\n              excessList: excessIDList,\n              timestamp: Date.now()\n            });\n          }\n        }\n        if (!newCells.length) {\n          moreExpected = false;\n        } else {\n          const newPortalList = setBackwardCells(newCells);\n          if (newPortalList.length === cellPortalListRef.current.length) {\n            // something went wrong\n            if (callbacks.error) {\n              callbacks.error({\n                source: 'fetchCells, backward',\n                message: 'one or more errors found in fetched cellPacks. Loading aborted',\n                arguments: [direction, portalIDListRef.current[0], count],\n                return: newCells,\n                timestamp: Date.now()\n              });\n            }\n            break;\n          }\n          cellPortalListRef.current = newPortalList;\n          setPortalRenderList(newPortalList);\n          updateCurrentAxisReferenceID();\n        }\n      }\n    }\n  });\n  const setSeedCell = newCells => {\n    const cradleActual = cradleActualRef.current,\n      incomingPortalList = [],\n      cellPortalList = cellPortalListRef.current,\n      cellPack = newCells[0];\n    if (!(typeof cellPack == 'object' && react_1.default.isValidElement(cellPack.component) && (0, utilities_1.isValidID)(cellPack.id))) {\n      if (callbacks.error) {\n        callbacks.error({\n          source: 'fetchCells, seed',\n          message: 'cellPack must have valid id and component; seed cellPack ignored',\n          arguments: [cellPack],\n          timestamp: Date.now()\n        });\n      }\n      return cellPortalList;\n    }\n    const {\n      id,\n      component\n    } = cellPack;\n    // register cell data\n    cellDataListRef.current.push(cellPack);\n    portalIDListRef.current.push(id);\n    const container = (0, utilities_1.createContainer)(id, cellDimensionsRef.current, cradleActual.cellsPerBand, orientationRef.current, layoutRef.current);\n    portalContainerMapRef.current.set(id, container);\n    incomingPortalList.push((0, react_dom_1.createPortal)(component, container, id));\n    // allocate cell data\n    const band = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cradleActualRef.current.cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n    tailBandListRef.current.push(band);\n    leadTailblockBandRef.current.append(band); // first band belongs in lead tail band\n    band.append(container);\n    // update cradleActual\n    cradleActual.totalBands++;\n    cradleActual.forwardBands++;\n    cradleActual.forwardCells++;\n    cradleActual.totalCells++;\n    const newPortalList = cellPortalList.concat(incomingPortalList);\n    return newPortalList;\n  };\n  const setForwardCells = newCells => {\n    const incomingPortalList = [],\n      cellPortalList = cellPortalListRef.current;\n    if (!newCells.every(cellPack => {\n      const isInvalid = !(typeof cellPack == 'object' && react_1.default.isValidElement(cellPack.component) && (0, utilities_1.isValidID)(cellPack.id));\n      if (isInvalid && callbacks.error) {\n        callbacks.error({\n          source: 'fetchCells, forward',\n          message: 'cellPack must have valid id and component',\n          arguments: [cellPack],\n          timestamp: Date.now()\n        });\n      }\n      let isDuplicate = false;\n      if (!isInvalid) {\n        isDuplicate = portalContainerMapRef.current.has(cellPack.id);\n        if (isDuplicate && callbacks.error) {\n          callbacks.error({\n            source: 'fetchCells, forward',\n            message: 'fetched cellPack is a duplicate',\n            arguments: [cellPack],\n            timestamp: Date.now()\n          });\n        }\n      }\n      return !isDuplicate && !isInvalid;\n    })) {\n      return cellPortalList;\n    }\n    const cradleActual = cradleActualRef.current;\n    newCells.forEach(cellPack => {\n      // register cell data\n      cellDataListRef.current.push(cellPack);\n      const {\n        id,\n        component\n      } = cellPack;\n      portalIDListRef.current.push(id);\n      const container = (0, utilities_1.createContainer)(id, cellDimensionsRef.current, cradleActual.cellsPerBand, orientationRef.current, layoutRef.current);\n      portalContainerMapRef.current.set(id, container);\n      incomingPortalList.push((0, react_dom_1.createPortal)(component, container, id));\n      // allocate cell data\n      let band;\n      const latestband = tailBandListRef.current.at(-1);\n      if (latestband && latestband.childElementCount < cradleActual.cellsPerBand) {\n        band = latestband;\n      } else {\n        band = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cradleActual.cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n        if (tailBandListRef.current.length == 0) {\n          leadTailblockBandRef.current.append(band);\n        } else {\n          tailblockRef.current.append(band);\n        }\n        tailBandListRef.current.push(band);\n        cradleActual.totalBands++;\n        cradleActual.forwardBands++;\n      }\n      band.append(container);\n      cradleActual.forwardCells++;\n      cradleActual.totalCells++;\n    });\n    const newPortalList = cellPortalList.concat(incomingPortalList);\n    return newPortalList;\n  };\n  const setBackwardCells = newCells => {\n    const incomingPortalList = [],\n      cellPortalList = cellPortalListRef.current;\n    if (!newCells.every(cellPack => {\n      const isInvalid = !(typeof cellPack == 'object' && react_1.default.isValidElement(cellPack.component) && (0, utilities_1.isValidID)(cellPack.id));\n      if (isInvalid && callbacks.error) {\n        callbacks.error({\n          source: 'fetchCells, backward',\n          message: 'cellPack must have valid id and component',\n          arguments: [cellPack],\n          timestamp: Date.now()\n        });\n      }\n      let isDuplicate = false;\n      if (!isInvalid) {\n        isDuplicate = portalContainerMapRef.current.has(cellPack.id);\n        if (isDuplicate && callbacks.error) {\n          callbacks.error({\n            source: 'fetchCells, backward',\n            message: 'fetched cellPack is a duplicate',\n            arguments: [cellPack],\n            timestamp: Date.now()\n          });\n        }\n      }\n      return !isDuplicate && !isInvalid;\n    })) {\n      return cellPortalList;\n    }\n    const cradleActual = cradleActualRef.current;\n    newCells.forEach(cellPack => {\n      // register cell data\n      cellDataListRef.current.unshift(cellPack);\n      const {\n        id,\n        component\n      } = cellPack;\n      portalIDListRef.current.unshift(id);\n      const container = (0, utilities_1.createContainer)(id, cellDimensionsRef.current, cradleActualRef.current.cellsPerBand, orientationRef.current, layoutRef.current);\n      portalContainerMapRef.current.set(id, container);\n      incomingPortalList.unshift((0, react_dom_1.createPortal)(component, container, id));\n      // allocate cell data\n      let band;\n      const latestband = headBandListRef.current[0];\n      if (!latestband) {\n        const firstband = tailBandListRef.current[0]; // there may be room in the tail firstband\n        if (firstband.childElementCount < cradleActual.cellsPerBand) {\n          band = firstband;\n          band.prepend(container);\n          cradleActual.forwardCells++;\n          cradleActual.totalCells++;\n          return;\n        }\n      }\n      if (latestband && latestband.childElementCount < cradleActual.cellsPerBand) {\n        band = latestband;\n      } else {\n        band = (0, utilities_1.createBand)(orientationRef.current, layoutRef.current, cradleActual.cellsPerBand, spacingRef.current, bandMutationObserverRef.current);\n        if (headBandListRef.current.length == 0) {\n          leadHeadblockBandRef.current.append(band);\n        } else {\n          headblockRef.current.prepend(band);\n        }\n        headBandListRef.current.unshift(band);\n        cradleActual.totalBands++;\n        cradleActual.backwardBands++;\n      }\n      band.prepend(container);\n      cradleActual.backwardCells++;\n      cradleActual.totalCells++;\n    });\n    const newPortalList = incomingPortalList.concat(cellPortalList);\n    return newPortalList;\n  };\n  return getCells;\n};\nexports[\"default\"] = useCells;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/useCells.tsx?")},"./src/useIntersections.tsx":function(__unused_webpack_module,exports,__webpack_require__){eval("\n\n// useIntersections.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ \"react\");\nconst useIntersections = ({\n  // constants\n  STANDARD_SCROLL_MOMENTUM_FADE,\n  AXIS_START_POSITION,\n  orientationRef,\n  // DOM elements\n  viewportRef,\n  headblockRef,\n  leadHeadblockBandRef,\n  headblockOverflowTriggerRef,\n  tailblockRef,\n  tailblockOverflowTriggerRef,\n  leadTailblockBandRef,\n  // state data\n  cradleActualRef,\n  cradlePotentialRef,\n  headBandListRef,\n  tailBandListRef,\n  intersectionsMapRef,\n  scrollTopRef,\n  scrollLeftRef,\n  axisPositionRef,\n  portalIDListRef,\n  // control data\n  immediateIsScrollingRef,\n  immediateStopScrollingRef,\n  restoreScrollingTimeoutIDRef,\n  // methods\n  // callbacksRef,\n  setAxisPosition,\n  intersectionsDisconnect,\n  intersectionsConnect,\n  fillCradle,\n  updateCurrentAxisReferenceID,\n  trimCradle\n}) => {\n  // -------------------------[ intersection observations controller ]-------------------------\n  const evaluateIntersections = (0, react_1.useCallback)(source => __awaiter(void 0, void 0, void 0, function* () {\n    if (!viewportRef.current) return;\n    if (intersectionsMapRef.current.size < 7) return; // incomplete initialization\n    if (!portalIDListRef.current.length) return;\n    const intersectionsMap = intersectionsMapRef.current,\n      leadHeadblockBand = intersectionsMap.get('lead-headblock-band'),\n      headblockOverflowTrigger = intersectionsMap.get('headblock-overflow-trigger'),\n      leadHeadblockBandBackwardTrigger = intersectionsMap.get('lead-headblock-band-backward-trigger'),\n      leadTailblockBand = intersectionsMap.get('lead-tailblock-band'),\n      leadTailblockBandEndTrigger = intersectionsMap.get('lead-tailblock-band-end-trigger'),\n      leadTailblockBandForwardTrigger = intersectionsMap.get('lead-tailblock-band-forward-trigger'),\n      tailblockOverflowTrigger = intersectionsMap.get('tailblock-overflow-trigger');\n    // --- complete overshoot - defensive\n    const allAreBefore = headblockOverflowTrigger.rs3position == 'before' && leadHeadblockBand.rs3position == 'before' && leadHeadblockBandBackwardTrigger.rs3position == 'before' && leadTailblockBand.rs3position == 'before' && leadTailblockBandForwardTrigger.rs3position == 'before' && leadTailblockBandEndTrigger.rs3position == 'before' && tailblockOverflowTrigger.rs3position == 'before',\n      allAreAfter = headblockOverflowTrigger.rs3position == 'after' && leadHeadblockBand.rs3position == 'after' && leadHeadblockBandBackwardTrigger.rs3position == 'after' && leadTailblockBand.rs3position == 'after' && leadTailblockBandForwardTrigger.rs3position == 'after' && leadTailblockBandEndTrigger.rs3position == 'after' && tailblockOverflowTrigger.rs3position == 'after';\n    if (allAreBefore || allAreAfter) {\n      console.log('WARNING: POSITION RECOVERY', 'from all', allAreBefore ? 'before' : 'after');\n      intersectionsDisconnect();\n      if (immediateIsScrollingRef.current) {\n        viewportRef.current.style.overflow = 'hidden';\n        immediateStopScrollingRef.current = true;\n        scrollTopRef.current = viewportRef.current.scrollTop;\n        scrollLeftRef.current - viewportRef.current.scrollLeft;\n        clearTimeout(restoreScrollingTimeoutIDRef.current);\n        restoreScrollingTimeoutIDRef.current = setTimeout(() => {\n          immediateStopScrollingRef.current = false;\n          viewportRef.current && (viewportRef.current.style.overflow = 'auto');\n        }, STANDARD_SCROLL_MOMENTUM_FADE);\n      }\n      if (orientationRef.current == 'vertical') {\n        immediateStopScrollingRef.current = false;\n        setAxisPosition(0, AXIS_START_POSITION - 1, 'outside');\n        viewportRef.current.scrollTo(scrollLeftRef.current, AXIS_START_POSITION);\n      } else {\n        // 'horizontal'\n        immediateStopScrollingRef.current = false;\n        setAxisPosition(AXIS_START_POSITION - 1, 0, 'outside');\n        viewportRef.current.scrollTo(AXIS_START_POSITION, scrollTopRef.current);\n      }\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n      return;\n    }\n    // --- oversize band vs viewport\n    if (leadHeadblockBand.rs3position == 'in' || leadTailblockBand.rs3position == 'in') {\n      const allTriggersAreOutside = headblockOverflowTrigger.rs3position != 'in' && leadHeadblockBandBackwardTrigger.rs3position != 'in' && tailblockOverflowTrigger.rs3position != 'in' && leadTailblockBandForwardTrigger.rs3position != 'in' && leadTailblockBandEndTrigger.rs3position != 'in';\n      if (allTriggersAreOutside && (leadHeadblockBand.rs3position == 'in' && leadTailblockBand.rs3position != 'in' || leadHeadblockBand.rs3position != 'in' && leadTailblockBand.rs3position == 'in')) {\n        // one of the leadbands is oversized\n        // console.log('OVERSIZE BAND')\n        return; // ... so do nothing\n      }\n    }\n    // --- head overflow\n    if (headblockOverflowTrigger.rs3position != 'before') {\n      // console.log('HEAD OVERFLOW')\n      intersectionsDisconnect();\n      if (immediateIsScrollingRef.current) {\n        viewportRef.current.style.overflow = 'hidden';\n        immediateStopScrollingRef.current = true;\n        scrollTopRef.current = viewportRef.current.scrollTop;\n        scrollLeftRef.current = viewportRef.current.scrollLeft;\n        clearTimeout(restoreScrollingTimeoutIDRef.current);\n        restoreScrollingTimeoutIDRef.current = setTimeout(() => {\n          immediateStopScrollingRef.current = false;\n          viewportRef.current && (viewportRef.current.style.overflow = 'auto');\n        }, STANDARD_SCROLL_MOMENTUM_FADE);\n      }\n      adjustForHeadOverflow();\n      yield fillCradle();\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n      return;\n    }\n    // --- tail overflow\n    if (tailblockOverflowTrigger.rs3position != 'after' && headBandListRef.current.length) {\n      // console.log('TAIL OVERFLOW')\n      intersectionsDisconnect();\n      if (immediateIsScrollingRef.current) {\n        viewportRef.current.style.overflow = 'hidden';\n        immediateStopScrollingRef.current = true;\n        scrollTopRef.current = viewportRef.current.scrollTop;\n        scrollLeftRef.current - viewportRef.current.scrollLeft;\n        clearTimeout(restoreScrollingTimeoutIDRef.current);\n        restoreScrollingTimeoutIDRef.current = setTimeout(() => {\n          immediateStopScrollingRef.current = false;\n          viewportRef.current && (viewportRef.current.style.overflow = 'auto');\n        }, STANDARD_SCROLL_MOMENTUM_FADE);\n      }\n      adjustForTailOverflow();\n      yield fillCradle();\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n      return;\n    }\n    // shift axis backward\n    if (leadHeadblockBandBackwardTrigger.rs3position == 'in') {\n      intersectionsDisconnect();\n      const headBandList = tailBandListRef.current;\n      let bandCount = 0;\n      if (orientationRef.current == 'vertical') {\n        const axisGap = leadHeadblockBandBackwardTrigger.boundingClientRect.bottom - leadHeadblockBandBackwardTrigger.rootBounds.top;\n        let bandIndex = headBandList.length - 1;\n        let bandHeightSpan = headBandList[bandIndex].offsetHeight;\n        let nextHeight = 0;\n        while (bandHeightSpan + nextHeight < axisGap) {\n          bandHeightSpan += nextHeight;\n          bandIndex--;\n          if (bandIndex < 0) break;\n          nextHeight = headBandList[bandIndex].offsetHeight;\n        }\n        bandCount = headBandList.length - bandIndex;\n      } else {\n        // 'horizontal'\n        const axisGap = leadHeadblockBandBackwardTrigger.boundingClientRect.right - leadHeadblockBandBackwardTrigger.rootBounds.left;\n        let bandIndex = headBandList.length - 1;\n        let bandWidthSpan = headBandList[bandIndex].offsetWidth;\n        let nextWidth = 0;\n        while (bandWidthSpan + nextWidth < axisGap) {\n          bandWidthSpan += nextWidth;\n          bandIndex--;\n          if (bandIndex < 0) break;\n          nextWidth = headBandList[bandIndex].offsetHeight;\n        }\n        bandCount = headBandList.length - bandIndex;\n      }\n      const count = bandCount;\n      // console.log('SHIFT AXIS BACKWARD', count)\n      shiftAxis('backward', count); // axis backward, bands forward\n      yield fillCradle();\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n      return;\n    }\n    // --- shift axis forward\n    if (leadTailblockBandForwardTrigger.rs3position == 'before') {\n      intersectionsDisconnect();\n      const tailBandList = tailBandListRef.current;\n      let bandCount = 0;\n      if (!tailBandList.length) return;\n      if (orientationRef.current == 'vertical') {\n        const axisGap = leadTailblockBandForwardTrigger.rootBounds.top - leadTailblockBandForwardTrigger.boundingClientRect.bottom;\n        let bandIndex = tailBandList.length - 1;\n        let bandHeightSpan = tailBandList[bandIndex].offsetHeight;\n        let nextHeight = 0;\n        while (bandHeightSpan + nextHeight < axisGap) {\n          bandHeightSpan += nextHeight;\n          bandIndex--;\n          if (bandIndex < 0) break;\n          nextHeight = tailBandList[bandIndex].offsetHeight;\n        }\n        bandCount = tailBandList.length - bandIndex;\n      } else {\n        // 'horizontal'\n        const axisGap = leadHeadblockBandBackwardTrigger.rootBounds.left - leadHeadblockBandBackwardTrigger.boundingClientRect.right;\n        let bandIndex = tailBandList.length - 1;\n        let bandWidthSpan = tailBandList[bandIndex].offsetWidth;\n        let nextWidth = 0;\n        while (bandWidthSpan + nextWidth < axisGap) {\n          bandWidthSpan += nextWidth;\n          bandIndex--;\n          if (bandIndex < 0) break;\n          nextWidth = tailBandList[bandIndex].offsetHeight;\n        }\n        bandCount = tailBandList.length - bandIndex;\n      }\n      const axisshiftcount = bandCount;\n      // console.log('SHIFT AXIS FORWARD', axisshiftcount) \n      shiftAxis('forward', axisshiftcount); // axis forward, bands backward\n      yield fillCradle();\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n      return;\n    }\n  }), []);\n  // -------------------------[ intersection observations support ]-------------------------\n  const adjustForHeadOverflow = () => {\n    const cradleActual = cradleActualRef.current;\n    if (!cradleActual.backwardBands) {\n      // reposition\n      if (orientationRef.current == 'vertical') {\n        scrollTopRef.current = AXIS_START_POSITION;\n        viewportRef.current.scrollTo(scrollLeftRef.current, AXIS_START_POSITION);\n        setAxisPosition(0, AXIS_START_POSITION - 1, 'head overflow');\n      } else {\n        // 'horizontal'\n        viewportRef.current.scrollTo(AXIS_START_POSITION, scrollTopRef.current);\n        scrollLeftRef.current = AXIS_START_POSITION;\n        setAxisPosition(AXIS_START_POSITION - 1, 0, 'head overflow');\n      }\n    } else {\n      // reposition axis to top\n      console.log('SHIFT AXIS BACKWARD (from head overflow)');\n      shiftAxis('backward', cradleActual.backwardBands);\n    }\n    cradleActual.totalCells = cradleActual.forwardCells + cradleActual.backwardCells;\n    cradleActual.totalBands = cradleActual.forwardBands + cradleActual.backwardBands;\n  };\n  const adjustForTailOverflow = () => {\n    const tailTriggerRect = tailblockOverflowTriggerRef.current.getBoundingClientRect(),\n      viewportRect = viewportRef.current.getBoundingClientRect();\n    if (orientationRef.current == 'vertical') {\n      const gap = viewportRect.bottom - tailTriggerRect.top,\n        viewportHeight = viewportRect.height,\n        cradleHeight = headblockRef.current.offsetHeight + tailblockRef.current.offsetHeight + 2,\n        // 2 for triggers\n        available = cradleHeight - (viewportHeight - gap),\n        adjustment = Math.min(gap, available) + 3,\n        // PIXEL\n        currentAxisY = axisPositionRef.current.y;\n      adjustment && setAxisPosition(0, currentAxisY + adjustment, 'tail overflow');\n    } else {\n      // 'horizontal'\n      const gap = viewportRect.right - tailTriggerRect.left,\n        viewportWidth = viewportRect.width,\n        cradleWidth = headblockRef.current.offsetWidth + tailblockRef.current.offsetWidth + 2,\n        // 2 for triggers\n        available = cradleWidth - (viewportWidth - gap),\n        adjustment = Math.min(gap, available) + 3,\n        currentAxisX = axisPositionRef.current.x;\n      adjustment && setAxisPosition(currentAxisX + adjustment, 0);\n    }\n  };\n  // assumes count is correct\n  const shiftAxis = (direction, axisShiftCount) => {\n    const cradleActual = cradleActualRef.current,\n      cradlePotential = cradlePotentialRef.current,\n      headblock = headblockRef.current,\n      backwardBandList = headBandListRef.current,\n      tailblock = tailblockRef.current,\n      forwardBandList = tailBandListRef.current,\n      leadHeadblockBand = leadHeadblockBandRef.current,\n      leadTailblockBand = leadTailblockBandRef.current;\n    if (direction == 'forward') {\n      // moves axis forward,  by moving bands from forwardBands to backwardBands\n      for (let count = 1; count <= axisShiftCount; count++) {\n        const forwardFirstBand = forwardBandList.shift(),\n          // get the band to move\n          forwardNextBand = forwardBandList[0],\n          // next in line, to replace moved band\n          backwardFirstBand = backwardBandList.at(-1); // for insert moved band before\n        backwardBandList.push(forwardFirstBand); // add moved band\n        const bandContainerCount = forwardFirstBand.childElementCount;\n        cradleActual.forwardBands--;\n        cradleActual.forwardCells -= bandContainerCount;\n        cradleActual.backwardBands++;\n        cradleActual.backwardCells += bandContainerCount;\n        // move axis forward\n        backwardFirstBand && leadHeadblockBand.before(backwardFirstBand); // move down to make room \n        // move band from backward to forward, axis backward\n        leadHeadblockBand.append(forwardFirstBand); // replace with new band\n        forwardNextBand && leadTailblockBand.append(forwardNextBand); // replace moved band with next band\n        if (orientationRef.current == 'vertical') {\n          const currentPx = axisPositionRef.current.y,\n            movedHeight = forwardFirstBand.offsetHeight;\n          setAxisPosition(0, currentPx + movedHeight, 'forward shift'); // PIXEL\n        } else {\n          // horizontal}\n          const currentPx = axisPositionRef.current.x,\n            movedWidth = forwardFirstBand.offsetWidth;\n          setAxisPosition(currentPx + movedWidth, 0);\n        }\n      }\n    } else {\n      // 'backward'\n      if (!backwardBandList.length) {\n        // beginning of available cradle bands\n        if (orientationRef.current == 'vertical') {\n          setAxisPosition(0, viewportRef.current.scrollTop - 1); // PIXEL\n        } else {\n          setAxisPosition(viewportRef.current.scrollLeft - 1, 0);\n        }\n        return;\n      }\n      for (let count = axisShiftCount; count >= 1; count--) {\n        const backwardFirstBand = backwardBandList.pop(),\n          // get the first band to move\n          backwardNextBand = backwardBandList.at(-1),\n          // next in line, for shift to replace first\n          forwardFirstBand = forwardBandList[0]; // for insert moved band after\n        // move forward band out of the way of the incoming backward band\n        forwardFirstBand && leadTailblockBand.after(forwardFirstBand);\n        // insert new band in forward list\n        leadTailblockBand.append(backwardFirstBand); // replace with new band\n        // record moved band in forward list\n        forwardBandList.unshift(backwardFirstBand); // add moved band\n        // move next band into moved band's place\n        backwardNextBand && leadHeadblockBand.append(backwardNextBand);\n        const bandContainerCount = backwardFirstBand.childElementCount;\n        cradleActual.forwardBands++;\n        cradleActual.forwardCells += bandContainerCount;\n        cradleActual.backwardBands--;\n        cradleActual.backwardCells -= bandContainerCount;\n        // move axis backward\n        if (orientationRef.current == 'vertical') {\n          const currentPx = axisPositionRef.current.y,\n            movedHeight = backwardFirstBand.offsetHeight;\n          setAxisPosition(0, currentPx - movedHeight, 'backward shift');\n        } else {\n          // horizontal\n          const currentPx = axisPositionRef.current.x,\n            movedWidth = backwardFirstBand.offsetWidth;\n          setAxisPosition(currentPx - movedWidth, 0);\n        }\n      }\n    }\n    trimCradle();\n    updateCurrentAxisReferenceID();\n  };\n  return evaluateIntersections;\n};\nexports[\"default\"] = useIntersections;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/useIntersections.tsx?")},"./src/useNewCradlePotential.tsx":function(__unused_webpack_module,exports,__webpack_require__){eval('\n\n// useCradlePotential.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ "react");\nconst utilities_1 = __webpack_require__(/*! ./utilities */ "./src/utilities.tsx");\nconst useCradlePotential = ({\n  orientationRef,\n  layoutRef,\n  spacingRef,\n  seedReferenceIDRef,\n  currentAxisReferenceIDRef,\n  cradleActualRef,\n  cellPortalListRef,\n  portalIDListRef,\n  portalContainerMapRef,\n  headblockRef,\n  headBandListRef,\n  leadHeadblockBandRef,\n  tailblockRef,\n  tailBandListRef,\n  leadTailblockBandRef,\n  // callbacksRef,\n  intersectionsDisconnect,\n  intersectionsConnect,\n  setPortalRenderList,\n  removeCells,\n  getSeed,\n  fillCradle,\n  updateCurrentAxisReferenceID,\n  bandMutationObserverRef\n}) => {\n  const applyNewCradlePotential = (0, react_1.useCallback)(cradlePotential => __awaiter(void 0, void 0, void 0, function* () {\n    // console.log(\'applyNewCradlePotential to actual\')\n    if (seedReferenceIDRef.current == null) return;\n    intersectionsDisconnect();\n    const cradleActual = cradleActualRef.current,\n      startingCradleActual = Object.assign({}, cradleActual),\n      cellPortalList = cellPortalListRef.current,\n      headBandList = headBandListRef.current,\n      tailBandList = tailBandListRef.current,\n      orientation = orientationRef.current,\n      layout = layoutRef.current,\n      portalIDList = portalIDListRef.current,\n      headblock = headblockRef.current,\n      tailblock = tailblockRef.current,\n      leadHeadblockBand = leadHeadblockBandRef.current,\n      leadTailblockBand = leadTailblockBandRef.current,\n      bandMutationObserver = bandMutationObserverRef.current;\n    // 1. adjust to cradlePotential from cradleActual\n    if (cradlePotential.cellsPerBand !== cradleActual.cellsPerBand) {\n      // update head and tail blocks\n      const newCellsPerBand = cradlePotential.cellsPerBand;\n      // update band layout pattern\n      const updateBand = band => {\n        const style = `repeat(${newCellsPerBand}, 1fr)`;\n        if (orientation == \'vertical\') {\n          band.style.gridTemplateColumns = style;\n        } else {\n          // horizontal\n          band.style.gridTemplateRows = style;\n        }\n      };\n      headBandList.forEach(band => {\n        updateBand(band);\n      });\n      tailBandList.forEach(band => {\n        updateBand(band);\n      });\n      // --------------------[ update headblock ]----------------------\n      const headBandsToFit = Math.min(cradlePotential.backwardBands, Math.ceil(startingCradleActual.backwardCells / newCellsPerBand));\n      let newBackwardCellCount = 0;\n      // add any required new bands\n      if (headBandsToFit > cradleActual.backwardBands) {\n        const newBandCount = headBandsToFit - cradleActual.backwardBands;\n        for (let count = 1; count <= newBandCount; count++) {\n          const newband = (0, utilities_1.createBand)(orientation, layout, newCellsPerBand, spacingRef.current, bandMutationObserver);\n          if (headBandList.length === 0) {\n            leadHeadblockBand.append(newband);\n          } else {\n            headblock.prepend(newband);\n          }\n          headBandList.unshift(newband);\n          cradleActual.backwardBands++;\n        }\n      }\n      // replace all containers in headBandsToFit\n      if (headBandsToFit) {\n        let backwardCellIndex = cradleActual.backwardCells - 1;\n        for (let bandindex = headBandList.length - 1; bandindex >= headBandList.length - headBandsToFit; bandindex--) {\n          const offset = Math.min(backwardCellIndex - (newCellsPerBand - 1), 0),\n            // ragged edge\n            start = backwardCellIndex - (newCellsPerBand - 1) + offset,\n            count = newCellsPerBand + offset,\n            end = start + count,\n            cellIDsToReplace = portalIDList.slice(start, end),\n            containersForReplace = [];\n          backwardCellIndex -= cellIDsToReplace.length;\n          newBackwardCellCount += cellIDsToReplace.length;\n          cellIDsToReplace.forEach(referenceID => {\n            containersForReplace.push(portalContainerMapRef.current.get(referenceID));\n          });\n          const band = headBandList[bandindex];\n          band.replaceChildren(...containersForReplace);\n        }\n      }\n      // ------------------------[ update tailblock ]--------------------------\n      const tailBandsToFit = Math.min(cradlePotential.forwardBands, Math.ceil(startingCradleActual.forwardCells / newCellsPerBand));\n      let newForwardCellCount = 0;\n      // add any required new bands\n      if (tailBandsToFit > cradleActual.forwardBands) {\n        const newBandsCount = tailBandsToFit - cradleActual.forwardBands;\n        for (let count = 1; count <= newBandsCount; count++) {\n          const newband = (0, utilities_1.createBand)(orientation, layout, newCellsPerBand, spacingRef.current, bandMutationObserver);\n          if (tailBandList.length === 0) {\n            leadTailblockBand.append(newband);\n          } else {\n            tailblock.append(newband);\n          }\n          tailBandList.push(newband);\n          cradleActual.forwardBands++;\n        }\n      }\n      // replace all containers in tailBandsToFit\n      if (tailBandsToFit) {\n        let forwardCellIndex = cradleActual.backwardCells;\n        for (let bandindex = 0; bandindex < tailBandsToFit; bandindex++) {\n          const offset = Math.min(portalIDList.length - 1 - (forwardCellIndex + (newCellsPerBand - 1)), 0),\n            start = forwardCellIndex,\n            count = newCellsPerBand + offset,\n            end = start + count,\n            cellIDsToReplace = portalIDList.slice(start, end),\n            containersForReplace = [];\n          forwardCellIndex += cellIDsToReplace.length;\n          newForwardCellCount += cellIDsToReplace.length;\n          cellIDsToReplace.forEach(referenceID => {\n            containersForReplace.push(portalContainerMapRef.current.get(referenceID));\n          });\n          const band = tailBandList[bandindex];\n          band.replaceChildren(...containersForReplace);\n        }\n      }\n      // ---------------------------[ sync records and new cradleActual ]------------------------\n      // const countlist = []\n      // headBandListRef.current.forEach((band)=>{\n      //     countlist.push(band.childElementCount)\n      // })\n      // pending changes:\n      const backwardBandsToRemoveCount = Math.max(startingCradleActual.backwardBands - headBandsToFit, 0),\n        backwardCellsToRemoveCount = Math.max(startingCradleActual.backwardCells - newBackwardCellCount, 0),\n        forwardBandsToRemoveCount = Math.max(startingCradleActual.forwardBands - tailBandsToFit, 0),\n        forwardCellsToRemoveCount = Math.max(startingCradleActual.forwardCells - newForwardCellCount, 0);\n      removeCells({\n        backwardCellsToRemoveCount,\n        forwardCellsToRemoveCount,\n        backwardBandsToRemoveCount,\n        forwardBandsToRemoveCount\n      });\n      // catch up\n      Object.assign(cradleActual, {\n        totalBands: cradleActual.backwardBands + cradleActual.forwardBands,\n        totalCells: newBackwardCellCount + newForwardCellCount,\n        cellsPerBand: newCellsPerBand\n      });\n      setPortalRenderList(cellPortalListRef.current);\n      updateCurrentAxisReferenceID();\n    } // end of change in cellsPerBand\n    // 2. get cells\n    if (!cellPortalList.length) {\n      // restock cells\n      yield getSeed(seedReferenceIDRef.current);\n      cradleActual.totalBands = cradleActual.backwardBands + cradleActual.forwardBands;\n      cradleActual.totalCells = cradleActual.backwardCells + cradleActual.forwardCells;\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n    } else {\n      yield fillCradle();\n      cradleActual.totalBands = cradleActual.backwardBands + cradleActual.forwardBands;\n      cradleActual.totalCells = cradleActual.backwardCells + cradleActual.forwardCells;\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n    }\n  }), []);\n  return applyNewCradlePotential;\n};\nexports["default"] = useCradlePotential;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/useNewCradlePotential.tsx?')},"./src/useRemoveCells.tsx":(__unused_webpack_module,exports)=>{eval('\n\n// useRemoveCells.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nconst useRemoveCells = ({\n  portalIDListRef,\n  cellPortalListRef,\n  cellDataListRef,\n  portalContainerMapRef,\n  headBandListRef,\n  tailBandListRef,\n  cradleActualRef,\n  callbacksRef\n}) => {\n  const removeCells = ({\n    backwardCellsToRemoveCount,\n    forwardCellsToRemoveCount,\n    backwardBandsToRemoveCount,\n    forwardBandsToRemoveCount\n  }) => {\n    var _a;\n    const portalIDList = portalIDListRef.current,\n      cellPortalList = cellPortalListRef.current,\n      cellDataList = cellDataListRef.current,\n      portalContainerMap = portalContainerMapRef.current,\n      headBandList = headBandListRef.current,\n      tailBandList = tailBandListRef.current,\n      cradleActual = cradleActualRef.current;\n    // --- remove cells\n    const forwardCellIDsToRemove = forwardCellsToRemoveCount ? portalIDList.splice(-forwardCellsToRemoveCount) : [],\n      backwardCellIDsToRemove = portalIDList.splice(0, backwardCellsToRemoveCount);\n    forwardCellIDsToRemove.forEach(ID => {\n      const container = portalContainerMap.get(ID);\n      container.remove();\n      portalContainerMap.delete(ID);\n    });\n    backwardCellIDsToRemove.forEach(ID => {\n      const container = portalContainerMap.get(ID);\n      container.remove();\n      portalContainerMap.delete(ID);\n    });\n    forwardCellsToRemoveCount && cellPortalList.splice(-forwardCellsToRemoveCount);\n    backwardCellsToRemoveCount && cellPortalList.splice(0, backwardCellsToRemoveCount);\n    forwardCellsToRemoveCount && cellDataList.splice(-forwardCellsToRemoveCount);\n    backwardCellsToRemoveCount && cellDataList.splice(0, backwardCellsToRemoveCount);\n    cradleActual.backwardCells -= backwardCellsToRemoveCount;\n    cradleActual.forwardCells -= forwardCellsToRemoveCount;\n    cradleActual.totalCells = cradleActual.backwardCells + cradleActual.forwardCells;\n    // ---remove bands\n    const headBandsToRemoveList = headBandList.splice(0, backwardBandsToRemoveCount),\n      tailBandsToRemoveList = forwardBandsToRemoveCount ? tailBandList.splice(-forwardBandsToRemoveCount) : [];\n    cradleActual.backwardBands -= backwardBandsToRemoveCount;\n    cradleActual.forwardBands -= forwardBandsToRemoveCount;\n    cradleActual.totalBands = cradleActual.backwardBands + cradleActual.forwardBands;\n    headBandsToRemoveList.forEach(band => {\n      band.parentElement.removeChild(band);\n    });\n    tailBandsToRemoveList.forEach(band => {\n      band.parentElement.removeChild(band);\n    });\n    if ((_a = callbacksRef.current) === null || _a === void 0 ? void 0 : _a.removed) {\n      const removedList = backwardCellIDsToRemove.concat(forwardCellIDsToRemove);\n      if (removedList.length) {\n        callbacksRef.current.removed(removedList);\n      }\n    }\n  };\n  return removeCells;\n};\nexports["default"] = useRemoveCells;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/useRemoveCells.tsx?')},"./src/useReset.tsx":function(__unused_webpack_module,exports,__webpack_require__){eval('\n\n// useReset.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nconst react_1 = __webpack_require__(/*! react */ "react");\nconst utilities_1 = __webpack_require__(/*! ./utilities */ "./src/utilities.tsx");\nconst useReset = ({\n  cradlePotentialRef,\n  portalContainerMapRef,\n  portalIDListRef,\n  cellPortalListRef,\n  cellDataListRef,\n  tailBandListRef,\n  headBandListRef,\n  cradleActualRef,\n  setPortalRenderList,\n  intersectionsDisconnect,\n  intersectionsConnect,\n  getSeed,\n  callbacksRef,\n  resetAxisPosition\n}) => {\n  const reset = (0, react_1.useCallback)(seedReferenceID => __awaiter(void 0, void 0, void 0, function* () {\n    // console.log(\'resetting with\', seedReferenceID)\n    var _a;\n    const cradlePotential = cradlePotentialRef.current;\n    // clear out existing portals\n    portalContainerMapRef.current.forEach(container => {\n      container.remove();\n    });\n    portalContainerMapRef.current.clear();\n    portalIDListRef.current.length = 0;\n    cellPortalListRef.current.length = 0;\n    setPortalRenderList([]);\n    // clear existing cell and band data\n    cellDataListRef.current.length = 0;\n    tailBandListRef.current.forEach(band => {\n      band.remove();\n    });\n    tailBandListRef.current.length = 0;\n    const headBandListLength = headBandListRef.current.length;\n    headBandListRef.current.forEach(band => {\n      band.remove();\n    });\n    headBandListRef.current.length = 0; // leave lead-head-band\n    let noSeedReferenceID = seedReferenceID !== null && seedReferenceID !== void 0 ? seedReferenceID : true;\n    if (!(noSeedReferenceID === true)) noSeedReferenceID = false;\n    cradleActualRef.current = Object.assign(Object.assign({}, utilities_1.baseCradleActual), {\n      orientation: cradlePotential.orientation,\n      layout: cradlePotential.layout,\n      cellsPerBand: cradlePotential.cellsPerBand\n    });\n    if (noSeedReferenceID) return;\n    const isInvalidID = !(0, utilities_1.isValidID)(seedReferenceID);\n    if (isInvalidID && ((_a = callbacksRef.current) === null || _a === void 0 ? void 0 : _a.error)) {\n      callbacksRef.current.error({\n        source: \'reset\',\n        message: \'must be a valid seed referenceID\',\n        arguments: [seedReferenceID],\n        timestamp: Date.now()\n      });\n    }\n    if (isInvalidID) return;\n    if (!cellPortalListRef.current.length) {\n      // restock cells\n      intersectionsDisconnect();\n      yield getSeed(seedReferenceID);\n      resetAxisPosition();\n      setTimeout(() => {\n        intersectionsConnect();\n      }, 1);\n    }\n  }), []);\n  return reset;\n};\nexports["default"] = useReset;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/useReset.tsx?')},"./src/utilities.tsx":(__unused_webpack_module,exports)=>{eval("\n\n// utilities.tsx\n// copyright (c) 2025-present Henrik Bechmann, Toronto, Licence: MIT\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createBand = exports.createContainer = exports.getCellGapFromSpacing = exports.getBandPaddingFromSpacing = exports.getCradleMarginsFromSpacing = exports.baseCradleActual = exports.isValidID = void 0;\n// ============================[ utilities ]============================\nconst isValidID = referenceID => {\n  return typeof referenceID == 'number' && !Number.isNaN(referenceID) || typeof referenceID == 'string';\n};\nexports.isValidID = isValidID;\nexports.baseCradleActual = {\n  cellsPerBand: null,\n  totalBands: 0,\n  forwardBands: 0,\n  backwardBands: 0,\n  forwardCells: 0,\n  backwardCells: 0,\n  totalCells: 0\n};\nconst getCradleMarginsFromSpacing = spacing => {\n  let cradleMargin = spacing === null || spacing === void 0 ? void 0 : spacing.cradleMargin;\n  cradleMargin = cradleMargin !== null && cradleMargin !== void 0 ? cradleMargin : [];\n  let [cradleMarginStart, cradleMarginEnd] = cradleMargin;\n  cradleMarginStart = cradleMarginStart !== null && cradleMarginStart !== void 0 ? cradleMarginStart : 0;\n  cradleMarginEnd = cradleMarginEnd !== null && cradleMarginEnd !== void 0 ? cradleMarginEnd : 0;\n  return [cradleMarginStart, cradleMarginEnd];\n};\nexports.getCradleMarginsFromSpacing = getCradleMarginsFromSpacing;\nconst getBandPaddingFromSpacing = spacing => {\n  let bandPadding = spacing === null || spacing === void 0 ? void 0 : spacing.bandPadding;\n  bandPadding = bandPadding !== null && bandPadding !== void 0 ? bandPadding : [];\n  let [bandPaddingStart, bandPaddingEnd] = bandPadding;\n  bandPaddingStart = bandPaddingStart !== null && bandPaddingStart !== void 0 ? bandPaddingStart : 0;\n  bandPaddingEnd = bandPaddingEnd !== null && bandPaddingEnd !== void 0 ? bandPaddingEnd : 0;\n  return [bandPaddingStart, bandPaddingEnd];\n};\nexports.getBandPaddingFromSpacing = getBandPaddingFromSpacing;\nconst getCellGapFromSpacing = spacing => {\n  let gap = spacing === null || spacing === void 0 ? void 0 : spacing.cellGap;\n  gap = gap !== null && gap !== void 0 ? gap : 0;\n  return gap;\n};\nexports.getCellGapFromSpacing = getCellGapFromSpacing;\nconst createContainer = (id, cellDimensions, cellsPerBand, orientation, layout) => {\n  const container = document.createElement('div');\n  container.setAttribute('data-type', 'portal-container');\n  container.setAttribute('data-id', id);\n  container.style.position = 'relative';\n  container.style.overflow = 'hidden';\n  container.style.boxSizing = 'border-box';\n  if (orientation == 'vertical') {\n    container.style.maxWidth = cellDimensions.maxWidth + 'px';\n    container.style.minWidth = cellDimensions.minWidth + 'px';\n    if (layout == 'uniform') {\n      container.style.height = cellDimensions.maxHeight + 'px';\n    } else {\n      // variable\n      container.style.minHeight = cellDimensions.minHeight + 'px';\n      container.style.maxHeight = cellDimensions.maxHeight + 'px';\n    }\n  } else {\n    'horizontal';\n    container.style.maxHeight = cellDimensions.maxHeight + 'px';\n    container.style.minHeight = cellDimensions.minHeight + 'px';\n    if (layout == 'uniform') {\n      container.style.width = cellDimensions.maxWidth + 'px';\n    } else {\n      // variable\n      container.style.minWidth = cellDimensions.minWidth + 'px';\n      container.style.maxWidth = cellDimensions.maxWidth + 'px';\n    }\n  }\n  return container;\n};\nexports.createContainer = createContainer;\nconst createBand = (orientation, layout, cellsPerBand, spacing, bandMutationObserver) => {\n  const {\n      cellGap,\n      bandPadding,\n      cradleMargin\n    } = spacing,\n    band = document.createElement('div'),\n    [paddingStart, paddingEnd] = bandPadding,\n    [marginStart, marginEnd] = cradleMargin;\n  bandMutationObserver && bandMutationObserver.observe(band, {\n    childList: true\n  });\n  band.setAttribute('data-type', 'band');\n  band.style.display = 'grid';\n  band.style.boxSizing = 'border-box';\n  const style = `repeat(${cellsPerBand}, 1fr)`;\n  if (orientation == 'vertical') {\n    band.style.gridTemplateColumns = style;\n    band.style.paddingTop = paddingStart + 'px';\n    band.style.paddingBottom = paddingEnd + 'px';\n    band.style.paddingLeft = marginStart + 'px';\n    band.style.paddingRight = marginEnd + 'px';\n    band.style.columnGap = cellGap + 'px';\n    band.style.minWidth = '100%';\n    if (layout == 'variable') {\n      band.style.gridTemplateRows = 'max-content';\n    }\n  } else {\n    // horizontal\n    band.style.gridTemplateRows = style;\n    band.style.paddingLeft = paddingStart + 'px';\n    band.style.paddingRight = paddingEnd + 'px';\n    band.style.paddingTop = marginStart + 'px';\n    band.style.paddingBottom = marginEnd + 'px';\n    band.style.rowGap = cellGap + 'px';\n    band.style.minHeight = '100%';\n    if (layout == 'variable') {\n      band.style.gridTemplateColumns = 'max-content';\n    }\n  }\n  return band;\n};\nexports.createBand = createBand;\n\n//# sourceURL=webpack://react-super-simple-scroller/./src/utilities.tsx?")},react:e=>{e.exports=__WEBPACK_EXTERNAL_MODULE_react__},"react-dom":e=>{e.exports=__WEBPACK_EXTERNAL_MODULE_react_dom__}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__("./src/ReactSuperSimpleScroller.tsx");return __webpack_exports__})());